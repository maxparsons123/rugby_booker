<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Black Cab Unite ‚Äî Coventry Rugby (Butts Park Arena) v3.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#1f6feb" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css        " />
  <style>
    :root{--accent:#1f6feb;--accent-2:#ff7b00;--bg:#f7fafc;--card:#ffffff;}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;background:var(--bg);color:#111;}
    .container{display:flex;flex-direction:column;height:100vh;gap:12px;padding:12px;box-sizing:border-box;overflow:hidden;}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;}
    .brand{display:flex;align-items:center;gap:10px;}
    .brand h1{margin:0;font-size:20px;letter-spacing:0.5px;}
    .small{font-size:13px;color:#666;}
    .tablet-info{text-align:right;font-size:13px;color:#444;}
    .main{display:flex;gap:12px;flex:1;min-height:0;}
    #map{flex:1;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,0.08);background-color:#e0e0e0;} /* Added background color for clarity */
    .panel{
      width:360px;
      min-width:260px;
      background:var(--card);
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,0.06);
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    /* Static Booking Panel */
    .booking-panel{
      padding:12px;
      border-bottom:1px solid #eee;
      background:#f9f9f9;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .booking-row{
      display:flex;
      gap:8px;
    }
    .booking-row input{
      width:100%;
      padding:8px;
      border-radius:8px;
      border:1px solid #ccc;
      font-size:15px;
    }
    .order-btn{
      background:var(--accent);
      color:white;
      border:none;
      padding:14px;
      font-size:17px;
      font-weight:600;
      border-radius:10px;
      cursor:pointer;
      width:100%;
      box-shadow:0 4px 8px rgba(31,111,235,0.2);
    }
    .order-btn:active{transform:translateY(1px);}
    /* Scrollable Content */
    .scroll-content{
      flex:1;
      overflow-y:auto;
      padding:20px;
    }
    .clear-btn{
      background:#dc3545;
      color:white;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      margin-top:8px;
      width:100%;
    }
    .clear-btn:hover{background:#c82333;}
    .small{font-size:13px;color:#666;}
    .status{padding:10px;border-radius:8px;background:#f2f6ff;color:#08306b;font-weight:600;}
    .driver-list{display:flex;flex-direction:column;gap:8px;max-height:140px;overflow:auto;}
    .driver-item{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:8px;border-radius:8px;background:#fff;border:1px solid #f0f0f0; cursor: pointer; /* Added cursor pointer */}
    .driver-item:hover { background-color: #f0f0f0; /* Added hover effect */ }
    .small-btn{
      border:1px solid #ddd;
      background:#fff;
      padding:6px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    table{width:100%;border-collapse:collapse;}
    th,td{
      padding:8px 4px;
      text-align:left;
      border-bottom:1px solid #eee;
      font-size:14px;
    }
    th{background:#f0f0f0;font-size:13px;}
    tbody td{font-weight:600;}
    /* Job Table Row Hover */
    tbody tr:hover {
      background-color: #f0f8ff;
    }
    footer{display:flex;justify-content:space-between;gap:12px;font-size:12px;color:#666;}
    .admin-panel{
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      background:#fff;
      padding:12px;
      border-radius:12px;
      box-shadow:0 6px 16px rgba(0,0,0,0.1);
      z-index:1000;
      display:none;
      width:300px;
    }
    .admin-panel h3{margin:0 0 10px 0;font-size:16px;}
    .admin-panel .close-btn{float:right;cursor:pointer;color:#555;}
    #logPanel{
      position:fixed;
      bottom:0;
      left:0;
      right:0;
      background:#fff;
      border-top:2px solid var(--accent);
      box-shadow:0 -4px 16px rgba(0,0,0,0.2);
      max-height:0;
      overflow:hidden;
      transition:max-height 0.4s ease;
      padding:0 12px;
      z-index: 2000;
    }
    #logPanel.open{max-height:40vh;padding:12px;}
    #logOutput{
      font-family:monospace;
      font-size:12px;
      white-space:pre-wrap;
      background:#f9fafc;
      padding:8px;
      border-radius:8px;
      height:100%;
      overflow:auto;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 3000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    .modal-content {
      background-color: white;
      margin: 15% auto;
      padding: 20px;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.2);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .modal-header h3 {
      margin: 0;
      font-size: 18px;
    }
    .close-modal {
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      color: #aaa;
    }
    .close-modal:hover {
      color: black;
    }
    .modal-body {
      margin-bottom: 15px;
    }
    .modal-footer {
      display: flex;
      gap: 10px;
    }
    .modal-btn {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      cursor: pointer;
    }
    .modal-btn.cancel {
      background-color: #dc3545;
      color: white;
    }
    .modal-btn.track {
      background-color: #28a745;
      color: white;
    }
    .modal-btn.close {
      background-color: #f8f9fa;
      color: #333;
      border: 1px solid #ddd;
    }

    @media(max-width:900px){
      .main{flex-direction:column;}
      .panel{width:100%;}
      .booking-row input{font-size:14px;}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <div style="width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,#004400,#228B22);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;"> rugby </div>
        <div>
          <h1>Black Cab Unite ‚Äî Coventry Rugby</h1>
          <div class="small">Butts Park Arena</div>
        </div>
      </div>
      <div class="tablet-info">
        <button class="small-btn" id="logBtn">View Log</button>
        <button class="small-btn" id="adminBtn">Admin Panel</button>
      </div>
    </header>

    <div class="main">
      <div id="map"></div>
      <div class="panel">
        <!-- Static Booking Panel -->
        <div class="booking-panel">
          <div class="booking-row">
            <input type="text" id="customerName" placeholder="Customer name" />
            <input type="tel" id="customerPhone" placeholder="+44 7123 456789" />
          </div>
          <button class="order-btn" id="orderBtn">ORDER TAXI</button>
          <button class="clear-btn" id="clearStorageBtn">üóëÔ∏è Clear All Data</button>
        </div>

        <!-- Scrollable Content -->
        <div class="scroll-content">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
            <div style="font-weight:700">Nearby Drivers</div>
            <button class="small-btn" id="simulateBtn">Toggle Sim Drivers</button>
          </div>
          <div class="driver-list" id="driverList"></div>

          <div style="margin-top:16px;">
            <div style="font-weight:700;margin-bottom:8px;">Current Jobs</div>
            <table id="jobsTable">
              <thead><tr><th>ID</th><th>Name</th><th>Phone</th><th>Driver</th><th>Status</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div>Black Cab Unite ‚Äî Coventry Rugby Club</div>
      <div>Topics: pubs/requests/{pub_id} ‚Ä¢ drivers/tokens ‚Ä¢ jobs/+/status</div>
    </footer>

    <!-- Admin Panel -->
    <div class="admin-panel" id="adminPanel">
      <span class="close-btn" id="closeAdmin">&times;</span>
      <h3>Admin Panel</h3>
      <div>
        <label>Driver ID:</label>
        <input type="text" id="adminDriverId" placeholder="driver-01" />
        <button class="small-btn" id="addDriverBtn">Add</button>
        <button class="small-btn" id="removeDriverBtn">Remove</button>
      </div>
      <div style="margin-top:8px;"><button class="small-btn" id="allowAllBtn">Debug: Allow All</button></div>
      <div style="margin-top:12px;"><strong>Allowed:</strong><ul id="allowedDriversList"></ul></div>
    </div>

    <!-- Slide-up Log Panel -->
    <div id="logPanel">
      <h3 style="margin:0 0 8px 0;">üìã Activity Log</h3>
      <div id="logOutput"></div>
      <button class="small-btn" onclick="clearLog()">Clear Log</button>
    </div>

    <!-- Modal -->
    <div id="jobModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="modalJobTitle">Job Details</h3>
          <span class="close-modal" id="closeModal">&times;</span>
        </div>
        <div class="modal-body">
          <p>Customer: <span id="modalCustomerName"></span></p>
          <p>Driver: <span id="modalDriverName"></span></p>
          <p>Status: <span id="modalStatusText"></span></p>
        </div>
        <div class="modal-footer">
          <button class="modal-btn close" id="modalCloseBtn">Close</button>
          <button class="modal-btn cancel" id="modalCancelBtn">Cancel Ride</button>
          <button class="modal-btn track" id="modalTrackBtn" style="display: none;">Track Driver</button>
        </div>
      </div>
    </div>

  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js        "></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js        "></script>
  <script>
    // === CONFIG ===
    const PUB_ID = 'coventry-rugby-butts-park';
    const PUB_NAME = 'Coventry Rugby ‚Äî Butts Park Arena';
    const PUB_COORDS = { lat: 52.407234, lng: -1.525504 };
    const BIDDING_WINDOW_MS = 60_000; // 60 seconds

    // ===== FCM PUSH VIA CLOUD FUNCTION (HTTP) =====
    const CLOUD_FUNCTION_URL = 'https://europe-west2-cabunite.cloudfunctions.net/sendJobAlertHttp        ';

    async function sendPushToDriver(driverId, fcmToken, jobId, reason) {
      if (!driverId || typeof driverId !== 'string' || driverId.trim() === '') {
        logMsg(`‚ö†Ô∏è Skip push: invalid driverId "${driverId}"`);
        return;
      }
      driverId = driverId.trim();

      if (!fcmToken) {
        logMsg(`‚ùå No FCM token for ${driverId}`);
        return;
      }

      try {
        logMsg(`üì§ Sending push to ${driverId} (reason: ${reason})...`);
        const response = await fetch(CLOUD_FUNCTION_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ driverId, fcmToken, jobId, reason })
        });

        const data = await response.json();

        if (response.ok && data.messageId) {
          logMsg(`‚úÖ Push sent to ${driverId} (${data.messageId})`);
        } else {
          logMsg(`‚ùå Push failed for ${driverId}: ${data.error || JSON.stringify(data)}`);
        }
      } catch (err) {
        logMsg(`‚ùå Push error for ${driverId}: ${err.message}`);
      }
    }

    // === SAFE JSON PARSING ===
    function safeParseJson(key, fallback) {
      const item = localStorage.getItem(key);
      if (item === null || item === '') return fallback;
      try {
        return JSON.parse(item);
      } catch (e) {
        console.warn(`Invalid JSON in localStorage.${key}:`, item);
        localStorage.removeItem(key);
        return fallback;
      }
    }

    // === STATE ===
    const drivers = {}; // { id: { lat, lng, data: { status, ... }, fcmToken, marker, lastActive, activeJobId } }
    const pendingJobs = {}; // { jobId: { ...jobData, bidCount, bids: { driverId: {lat, lng, ts} }, timeoutId } }
    let visibleJobs = safeParseJson('visibleJobs', {});
    let allowedDrivers = safeParseJson('allowedDrivers', []);
    let debugAllowAll = false;
    let simActive = false;
    let selectedJobId = null; // Track the job currently open in modal

    // === DOM ELEMENTS ===
    const el = {
      connectionStatus: document.getElementById('connectionStatus'),
      driverList: document.getElementById('driverList'),
      customerName: document.getElementById('customerName'),
      customerPhone: document.getElementById('customerPhone'),
      orderBtn: document.getElementById('orderBtn'),
      simulateBtn: document.getElementById('simulateBtn'),
      jobsTable: document.querySelector("#jobsTable tbody"),
      adminPanel: document.getElementById('adminPanel'),
      closeAdmin: document.getElementById('closeAdmin'),
      adminBtn: document.getElementById('adminBtn'),
      adminDriverId: document.getElementById('adminDriverId'),
      addDriverBtn: document.getElementById('addDriverBtn'),
      removeDriverBtn: document.getElementById('removeDriverBtn'),
      allowAllBtn: document.getElementById('allowAllBtn'),
      allowedDriversList: document.getElementById('allowedDriversList'),
      logBtn: document.getElementById('logBtn'),
      logPanel: document.getElementById('logPanel'),
      logOutput: document.getElementById('logOutput'),
      clearStorageBtn: document.getElementById('clearStorageBtn'),
      // Modal Elements
      jobModal: document.getElementById('jobModal'),
      modalJobTitle: document.getElementById('modalJobTitle'),
      modalCustomerName: document.getElementById('modalCustomerName'),
      modalDriverName: document.getElementById('modalDriverName'),
      modalStatusText: document.getElementById('modalStatusText'),
      modalCancelBtn: document.getElementById('modalCancelBtn'),
      modalTrackBtn: document.getElementById('modalTrackBtn'),
      modalCloseBtn: document.getElementById('modalCloseBtn'),
      closeModal: document.getElementById('closeModal')
    };

    // === LOGGING ===
    function logMsg(msg){
      const ts = new Date().toLocaleTimeString();
      const entry = `[${ts}] ${msg}\n`;
      const logs = (localStorage.getItem('activityLog') || '') + entry;
      localStorage.setItem('activityLog', logs);
      el.logOutput.textContent = logs;
      if (el.logOutput.parentElement.classList.contains('open')) {
        el.logOutput.scrollTop = el.logOutput.scrollHeight;
      }
    }

    el.logBtn.onclick = () => el.logPanel.classList.toggle('open');
    function clearLog(){ localStorage.removeItem('activityLog'); el.logOutput.textContent = ''; }

    // === CLEAR STORAGE BUTTON ===
    el.clearStorageBtn.onclick = () => {
      if (confirm("‚ö†Ô∏è Clear ALL data? This will remove jobs, drivers, logs, and settings.")) {
        localStorage.clear();
        visibleJobs = {};
        pendingJobs = {};
        // Note: drivers object is not cleared from localStorage, only state reset here
        for (let id in drivers) {
            if (drivers[id].marker) {
                map.removeLayer(drivers[id].marker);
            }
        }
        drivers = {};
        updateJobsTable();
        el.driverList.innerHTML = '';
        el.logOutput.textContent = '';
        logMsg("üóëÔ∏è All local storage cleared");
      }
    };

    // === MAP SETUP (OPTIMIZED FOR ONLINE SPEED) ===
    const map = L.map('map', {
        center: [PUB_COORDS.lat, PUB_COORDS.lng],
        zoom: 15,
        // ‚úÖ OPTIMIZE: Reduce unnecessary tile updates during zoom/pan
        updateWhenIdle: true,
        updateWhenZooming: false,
        // ‚úÖ OPTIMIZE: Unload tiles that are off-screen to save memory
        unloadInvisibleTiles: true,
        // ‚úÖ OPTIMIZE: Reuse tiles when possible
        reuseTiles: true,
        // ‚úÖ OPTIMIZE: Disable retina detection (simpler tiles)
        detectRetina: false,
        // ‚úÖ OPTIMIZE: Set max bounds to prevent loading unnecessary tiles
        maxBounds: [
            [52.0, -2.0], // Southwest
            [53.0, -1.0]  // Northeast (adjust as needed)
        ]
    });

    // ‚úÖ OPTIMIZE: Use a potentially faster tile provider (CartoDB Voyager)
    // You can switch back to OSM if this doesn't load faster on your tablet
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 18,
        // ‚úÖ OPTIMIZE: Reduce tile size if default (256) is too much
        tileSize: 256
    }).addTo(map);

    L.marker([PUB_COORDS.lat, PUB_COORDS.lng]).addTo(map).bindPopup(PUB_NAME);

    // === HELPERS ===
    function distanceMeters(a, b) {
      const R = 6371000;
      const toRad = x => x * Math.PI / 180;
      const œÜ1 = toRad(a.lat), œÜ2 = toRad(b.lat);
      const ŒîœÜ = toRad(b.lat - a.lat), ŒîŒª = toRad(b.lng - a.lng);
      const a_ = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
    }

    function getColorForDriver(driverId) {
      let hash = 0;
      for (let i = 0; i < driverId.length; i++) {
        hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
      }
      const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
      return "#" + "00000".substring(0, 6 - c.length) + c;
    }

    // === DRIVER MANAGEMENT (OPTIMIZED) ===
    // ‚úÖ OPTIMIZE: Debounce UI updates to prevent frequent DOM manipulations
    let refreshDriverListDebounced = null;
    function refreshDriverList() {
      if (refreshDriverListDebounced) {
        clearTimeout(refreshDriverListDebounced);
      }
      refreshDriverListDebounced = setTimeout(() => {
        el.driverList.innerHTML = '';
        Object.entries(drivers).forEach(([id, d]) => {
          const dist = distanceMeters(d, PUB_COORDS);
          const status = (d.data && d.data.status) || 'unknown'; // üî∏ Safe access
          const div = document.createElement('div');
          div.className = 'driver-item';
          div.innerHTML = `
            <div><b>${id}</b><div class="small">${status}</div></div>
            <div>${dist < 1000 ? dist.toFixed(0) + 'm' : (dist / 1000).toFixed(1) + 'km'}</div>
          `;
          // --- NEW: Add click event to zoom to driver ---
          div.onclick = () => {
              if (d.marker) {
                  map.flyTo([d.lat, d.lng], 16); // Fly to driver's location with zoom level 16
                  logMsg(`üìç Zoomed to driver ${id}`);
              } else {
                  logMsg(`‚ö†Ô∏è No marker found for driver ${id} to zoom.`);
              }
          };
          // --- END NEW ---
          el.driverList.appendChild(div);
        });
      }, 100); // Wait 100ms before updating, cancel if called again within that time
    }

    function updateDriver(id, lat, lng, meta = {}) {
      if (!id) return;
      if (!drivers[id]?.marker) {
        const color = getColorForDriver(id);
        drivers[id] = {
          lat, lng,
          data:  { status: 'idle', ...meta },
          marker: L.circleMarker([lat, lng], { color, radius: 8 }).addTo(map)
        };
        drivers[id].marker.bindPopup(id);
      } else {
        // ‚úÖ OPTIMIZE: Only update marker position if it's visible on the map
        if (map.getBounds().contains([lat, lng])) {
            drivers[id].marker.setLatLng([lat, lng]);
        } else {
            // If not visible, just update the stored position
            drivers[id].lat = lat;
            drivers[id].lng = lng;
        }
        drivers[id].data = { ...drivers[id].data, ...meta };
      }
      drivers[id].lastActive = Date.now();
      refreshDriverList(); // Use debounced version
    }

    // === MODAL LOGIC ===
    function openJobModal(jobId) {
      const job = visibleJobs[jobId];
      if (!job) {
        logMsg(`‚ö†Ô∏è Cannot open modal for unknown job: ${jobId}`);
        return;
      }

      selectedJobId = jobId;
      el.modalJobTitle.textContent = `Job ${jobId}`;
      el.modalCustomerName.textContent = job.customerName || 'Unknown';
      el.modalDriverName.textContent = job.driver || 'Not Assigned';
      el.modalStatusText.textContent = job.status;

      // Show/hide buttons based on status
      if (['allocated', 'picked_up'].includes(job.status)) {
        el.modalTrackBtn.style.display = 'block';
        el.modalCancelBtn.style.display = 'block';
      } else if (['queued', 'bidding', 'no_bids'].includes(job.status)) {
        el.modalTrackBtn.style.display = 'none';
        el.modalCancelBtn.style.display = 'block';
      } else { // Completed, cancelled, etc.
        el.modalTrackBtn.style.display = 'none';
        el.modalCancelBtn.style.display = 'none';
      }

      el.jobModal.style.display = 'block';
    }

    function closeJobModal() {
      el.jobModal.style.display = 'none';
      selectedJobId = null;
    }

    function cancelJob(jobId) {
      if (!jobId || !visibleJobs[jobId]) {
        logMsg(`‚ö†Ô∏è Cannot cancel unknown job: ${jobId}`);
        return;
      }

      if (!confirm(`Are you sure you want to cancel job ${jobId}?`)) {
        return;
      }

      // Remove the job from the visible list and local storage
      delete visibleJobs[jobId];
      updateJobsTable();
      localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));

      // Publish status update if connected
      if (client && client.connected) {
        client.publish(`jobs/${jobId}/status`, JSON.stringify({
          status: 'cancelled',
          driver: null, // Explicitly clear driver
          ts: Date.now()
        }));
        logMsg(`üì§ Cancelled job ${jobId} via MQTT`);
      } else {
        logMsg(`‚ö†Ô∏è MQTT disconnected. Job ${jobId} cancelled locally.`);
      }

      closeJobModal();
      logMsg(`‚úÖ Job ${jobId} cancelled by passenger and removed from list.`);
    }

    function trackDriver(jobId) {
      const job = visibleJobs[jobId];
      if (!job || !job.driver) {
        logMsg(`‚ö†Ô∏è Cannot track driver for job ${jobId} - no driver assigned.`);
        return;
      }

      const driver = drivers[job.driver];
      if (!driver) {
        logMsg(`‚ö†Ô∏è Driver ${job.driver} for job ${jobId} not found on map.`);
        return;
      }

      // Fly to driver's location
      map.flyTo([driver.lat, driver.lng], 16);
      logMsg(`üìç Tracking driver ${job.driver} for job ${jobId}`);
      closeJobModal();
    }

    // === EVENT LISTENERS FOR MODAL ===
    el.closeModal.onclick = closeJobModal;
    el.modalCloseBtn.onclick = closeJobModal;
    el.modalCancelBtn.onclick = () => {
      if (selectedJobId) cancelJob(selectedJobId);
    };
    el.modalTrackBtn.onclick = () => {
      if (selectedJobId) trackDriver(selectedJobId);
    };
    window.onclick = (event) => {
      if (event.target === el.jobModal) {
        closeJobModal();
      }
    };

    // === JOBS TABLE LOGIC (OPTIMIZED) ===
    // ‚úÖ OPTIMIZE: Debounce table updates
    let updateJobsTableDebounced = null;
    function updateJobsTable() {
        if (updateJobsTableDebounced) {
            clearTimeout(updateJobsTableDebounced);
        }
        updateJobsTableDebounced = setTimeout(() => {
            el.jobsTable.innerHTML = '';
            Object.entries(visibleJobs).forEach(([id, j]) => {
                const tr = document.createElement('tr');
                // Make the row clickable
                tr.onclick = () => openJobModal(id);
                tr.style.cursor = 'pointer';
                tr.innerHTML = `
                <td>${id}</td>
                <td>${j.customerName || '-'}</td>
                <td>${j.customerPhone || '-'}</td>
                <td>${j.driver || '-'}</td>
                <td>${j.status}</td>
                `;
                el.jobsTable.appendChild(tr);
            });
        }, 100); // Wait 100ms before updating, cancel if called again within that time
    }

    // === MQTT ===
    let client = null;
    function connectMQTT(){
      const statusEl = document.createElement('div');
      statusEl.className = 'status';
      statusEl.id = 'connectionStatus';
      statusEl.textContent = 'MQTT: connecting...';
      document.querySelector('.booking-panel').insertAdjacentElement('afterbegin', statusEl);
      
      // ‚úÖ OPTIMIZE: Increase connection timeout for slow networks
      client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt', { 
          connectTimeout: 10000, // Increased from 4000
          reconnectPeriod: 5000, // Increased from 1000
          // Optional: Reduce buffer sizes if needed
          // inflight: 5,
          // queueQoSZero: false
      });
      client.on('connect', () => {
        statusEl.textContent = 'MQTT: connected';
        logMsg('‚úÖ Connected to MQTT');
        client.subscribe(`drivers/+/location`);
        client.subscribe(`drivers/+/status`); // üëà SUBSCRIBE TO DRIVER STATUS CHANGES
        client.subscribe(`jobs/+/status`);
        client.subscribe('drivers/tokens');
        client.subscribe(`pubs/requests/${PUB_ID}`); // Explicit topic for this pub
        resendOfflineJobs();
      });

      client.on('message', (topic, msg) => {
        try {
          const data = JSON.parse(msg.toString());
          // ‚úÖ OPTIMIZE: Comment out detailed logging for speed (uncomment if needed for debugging)
          // logMsg(`üì° ${topic} -> ${JSON.stringify(data)}`);

          if (topic.endsWith('/location')) {
            const id = topic.split('/')[1];
            updateDriver(id, data.lat, data.lng, data);
          }

          // FCM TOKEN HANDLING
          if (topic === 'drivers/tokens') {
            const { driverId, fcmToken } = data;
            if (driverId && fcmToken) {
              if (!drivers[driverId]) {
                drivers[driverId] = {
                  lat: PUB_COORDS.lat,
                  lng: PUB_COORDS.lng,
                  data:    { label: 'Taxi', status: 'idle' },
                  fcmToken: fcmToken,
                  lastActive: Date.now()
                };
                const color = getColorForDriver(driverId);
                drivers[driverId].marker = L.circleMarker([PUB_COORDS.lat, PUB_COORDS.lng], { color, radius: 8 }).addTo(map);
                drivers[driverId].marker.bindPopup(driverId);
              } else {
                drivers[driverId].fcmToken = fcmToken;
                drivers[driverId].lastActive = Date.now();
              }
              logMsg(`‚úÖ FCM token received for ${driverId}`);
            }
          }

          // DRIVER STATUS CHANGES (for re-allocation)
          if (topic.startsWith("drivers/") && topic.endsWith("/status")) {
            const driverId = topic.split('/')[1];
            if (driverId === 'tokens') return; // Ignore tokens topic itself

            try {
              const status = data.status || 'unknown';
              const timestamp = data.ts || Date.now();

              // üî∏ Trust the topic for driver ID, not the payload
              if (data.driver && data.driver !== driverId) {
                logMsg(`‚ö†Ô∏è Driver ID mismatch: topic=${driverId}, payload.driver=${data.driver}. Using topic ID.`);
              }

              // üî∏ Initialize driver if not exists
              if (!drivers[driverId]) {
                drivers[driverId] = {
                  lat: PUB_COORDS.lat,
                  lng: PUB_COORDS.lng,
                  data:  { status },
                  fcmToken: null,
                  lastActive: timestamp,
                  activeJobId: null,
                  marker: null
                };

                // Create marker (use circleMarker for consistency)
                const color = getColorForDriver(driverId);
                drivers[driverId].marker = L.circleMarker([PUB_COORDS.lat, PUB_COORDS.lng], {
                  color,
                  radius: 8,
                  fillOpacity: 0.7
                }).addTo(map);
                drivers[driverId].marker.bindPopup(driverId);
              } else {
                // üî∏ Update ONLY the status (preserve other data like fcmToken, lat/lng, etc.)
                drivers[driverId].data.status = status;
              }

              // Always update lastActive
              drivers[driverId].lastActive = timestamp;

              // üî∏ Refresh UI
              refreshDriverList(); // Use debounced version
              logMsg(`üìä Driver ${driverId} status updated to: ${status}`);

              // === Re-allocation logic: if this driver had an allocated job but is now busy/offline ===
              const assignedJobId = Object.keys(visibleJobs).find(jobId => {
                const job = visibleJobs[jobId];
                return job.driver === driverId && job.status === 'allocated';
              });

              if (assignedJobId) {
                const job = visibleJobs[assignedJobId];
                if (status === 'busy' || status === 'offline') {
                  logMsg(`‚ö†Ô∏è Driver ${driverId} (allocated to job ${assignedJobId}) went ${status}. Re-allocating job.`);

                  // Create NEW job with fresh ID
                  const newJobId = 'job-' + Date.now().toString(36) + Math.random().toString(36).substring(2, 4);
                  const newJob = {
                    ...job,
                    job: newJobId,
                    status: 'queued',
                    driver: '-',
                    originalBidders: {} // üö´ Fresh bidder list ‚Äî no inheritance!
                  };

                  // Notify original bidders that original job is void
                  const originalBidders = Object.keys(job.originalBidders || {});
                  originalBidders.forEach(bidderId => {
                    if (client && client.connected) {
                      client.publish(`jobs/${assignedJobId}/result/${bidderId}`, JSON.stringify({ result: "driver_unavailable_for_original_job" }));
                      sendPushToDriver(bidderId, drivers[bidderId]?.fcmToken, assignedJobId, 'polite_better_luck_next_time');
                    }
                  });

                  // Replace old job with new one
                  delete visibleJobs[assignedJobId];
                  visibleJobs[newJobId] = newJob;
                  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));

                  // Publish new job (without internal fields)
                  const { originalBidders: _, ...jobForMqtt } = newJob;
                  if (client && client.connected) {
                    client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(jobForMqtt));
                  }

                  // Send FCM to eligible drivers for NEW job
                  const now = Date.now();
                  Object.entries(drivers).forEach(([id, driver]) => {
                    if (!id || !driver.fcmToken) return;
                    const isAllowed = debugAllowAll || allowedDrivers.includes(id);
                    const isFresh = (now - (driver.lastActive || 0)) < 60_000;
                    const inRange = distanceMeters(driver, PUB_COORDS) <= 10_000;
                    const isActive = ['available', 'idle'].includes(driver.data?.status);

                    if (isAllowed && isFresh && inRange && isActive && id !== driverId) { // ‚úÖ Excludes the unavailable driver
                      sendPushToDriver(id, driver.fcmToken, newJobId, 'reallocated_job');
                      newJob.originalBidders[id] = true;
                    }
                  });

                  logMsg(`üîÑ Re-allocated job. Old ID: ${assignedJobId}, New ID: ${newJobId}`);
                  updateJobsTable(); // Use debounced version
                }
              }
            } catch (err) {
              logMsg(`‚ùå Error handling status update for ${driverId}: ${err.message}`);
              console.error(err);
            }
          }

          // JOB STATUS UPDATES (BIDDING, COMPLETION, CANCELLATION, ETC.)
          if (topic.startsWith('jobs/') && topic.endsWith('/status')) {
            const jobId = topic.split('/')[1];
            if (visibleJobs[jobId]) {
              if (data.status === 'bidding' && data.driver) {
                if (!pendingJobs[jobId]) {
                  if (!visibleJobs[jobId]) {
                    logMsg(`‚ö†Ô∏è Received bid for unknown job: ${jobId}`);
                    return;
                  }
                  pendingJobs[jobId] = {
                    ...visibleJobs[jobId],
                    bidCount: 0,
                    bids: {},
                    timeoutId: setTimeout(() => finalizeBidding(jobId), BIDDING_WINDOW_MS)
                  };
                }
                if (!pendingJobs[jobId].bids[data.driver]) {
                  pendingJobs[jobId].bidCount += 1;
                  pendingJobs[jobId].bids[data.driver] = { lat: data.lat, lng: data.lng, timestamp: data.ts };
                  visibleJobs[jobId].status = `Bidding (${pendingJobs[jobId].bidCount})`;
                  visibleJobs[jobId].driver = '-';
                  updateJobsTable(); // Use debounced version
                  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
                  logMsg(`üì• Bid #${pendingJobs[jobId].bidCount} for ${jobId} from ${data.driver}`);
                } else {
                  logMsg(`‚è≠Ô∏è Duplicate bid from ${data.driver} for ${jobId} ignored.`);
                }
              }

              // --- HANDLING CANCELLATION: REMOVE JOB ---
              if (data.status === 'cancelled') {
                delete visibleJobs[jobId]; // Remove the job from the list
                updateJobsTable(); // Update the UI table - Use debounced version
                localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs)); // Update local storage
                logMsg(`‚úÖ Job ${jobId} removed from list (received cancelled status from MQTT).`);
                // Check if the cancelled job is the one currently open in the modal
                if (selectedJobId === jobId) {
                    closeJobModal(); // Close the modal if it was showing the cancelled job
                }
              }
              // --- END HANDLING CANCELLATION ---

              // --- Existing non-bidding status update (KEEP THIS for other statuses) ---
              if (data.status !== 'bidding' && data.status !== 'cancelled') {
                visibleJobs[jobId].status = data.status;
                visibleJobs[jobId].driver = data.driver || '-';
                updateJobsTable(); // Use debounced version
                localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
              }
            }
          }
        } catch(e) {
            console.warn("MQTT parse error:", e);
            logMsg(`‚ö†Ô∏è MQTT parse error: ${e.message}`);
        }
      });
    }

    function resendOfflineJobs() {
      const offlineQueue = safeParseJson('offlineQueue', []);
      if (offlineQueue.length === 0) return;
      offlineQueue.forEach(j => {
        client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(j));
        logMsg('‚òÅÔ∏è Resent job ' + j.job);
      });
      localStorage.setItem('offlineQueue', '[]');
    }


    // === JOBS ===
    function sendOrder() {
      const name = el.customerName.value.trim();
      const phone = el.customerPhone.value.trim();
      if (!name) return alert("Enter customer name");
      if (!phone) return alert("Enter customer phone");

      const jobId = 'job-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 2); // More unique ID
      const job = {
        job: jobId,
        pubName: PUB_NAME,
        customerName: name,
        customerPhone: phone,
        lat: PUB_COORDS.lat,
        lng: PUB_COORDS.lng,
        ts: Date.now(),
        status: 'queued',
        driver: '-',
        originalBidders: {} // Track bidders for this job
      };

      visibleJobs = { [jobId]: job, ...visibleJobs };
      localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
      updateJobsTable(); // Use debounced version

      if (client && client.connected) {
        client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(job));
        
        // Send FCM pushes
        const now = Date.now();
        Object.entries(drivers).forEach(([id, driver]) => {
          if (!id || !driver.fcmToken) return;
          const isAllowed = debugAllowAll || allowedDrivers.includes(id);
          const isFresh = (now - (driver.lastActive || 0)) < 60_000;
          const inRange = distanceMeters(driver, PUB_COORDS) <= 10_000;
          const isActive = driver.data?.status === 'available' || driver.data?.status === 'idle';
          
          let reason = 'eligible';
          if (!isAllowed) reason = 'not_allowed';
          else if (!isFresh) reason = 'gps_old';
          else if (!inRange) reason = 'out_of_range';
          else if (!isActive) reason = 'not_idle_or_available';
          
          if (reason === 'eligible') {
            sendPushToDriver(id, driver.fcmToken, jobId, reason);
            job.originalBidders[id] = true; // Track eligible driver
          }
        });
        
        logMsg('üì§ Sent job ' + jobId);
      } else {
        const offlineQueue = safeParseJson('offlineQueue', []);
        offlineQueue.push(job);
        localStorage.setItem('offlineQueue', JSON.stringify(offlineQueue));
        logMsg('üì¶ Stored offline job ' + jobId);
      }
      el.customerName.value = '';
      el.customerPhone.value = '';
    }

    // === FINALIZE BIDDING (60s) ===
    function finalizeBidding(jobId) {
      const job = pendingJobs[jobId];
      if (!job) return;

      let winner = null;
      const bids = Object.entries(job.bids || {});

      if (bids.length > 0) {
        const valid = bids.filter(([id]) => {
          const d = drivers[id];
          return d && (d.data?.status === 'idle' || d.data?.status === 'available');
        });

        if (valid.length > 0) {
          valid.sort(([aId, a], [bId, b]) => {
            const distA = distanceMeters(a, {lat: job.lat, lng: job.lng});
            const distB = distanceMeters(b, {lat: job.lat, lng: job.lng});
            return distA - distB;
          });
          winner = valid[0][0];
        }
      }

      if (winner) {
        visibleJobs[jobId].status = 'allocated';
        visibleJobs[jobId].driver = winner;
        client.publish(`jobs/${jobId}/result/${winner}`, JSON.stringify({ result: "won" }));
        bids.forEach(([driverId]) => {
          if (driverId !== winner) {
            client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "lost" }));
            // ‚úÖ SEND POLITE MESSAGE TO LOSER
            sendPushToDriver(driverId, drivers[driverId]?.fcmToken, jobId, 'polite_better_luck_next_time');
          }
        });
        logMsg(`üèÜ ${jobId} ‚Üí ${winner}`);
      } else {
        visibleJobs[jobId].status = 'no_bids';
        visibleJobs[jobId].driver = '-';
        bids.forEach(([driverId]) => {
          client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "no_valid_acceptance" }));
          // ‚úÖ SEND POLITE MESSAGE TO BIDDERS WHO DIDN'T ACCEPT
          sendPushToDriver(driverId, drivers[driverId]?.fcmToken, jobId, 'polite_no_valid_acceptance');
        });
        logMsg(`‚è∞ ${jobId}: no valid bids`);
      }

      delete pendingJobs[jobId];
      updateJobsTable(); // Use debounced version
      localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
    }

    // === SIMULATION ===
    function toggleSimDrivers(){
      simActive = !simActive;
      el.simulateBtn.innerText = simActive ? 'Stop Sim Drivers' : 'Toggle Sim Drivers';
      if (simActive) simLoop();
    }
    function simLoop(){
      if (!simActive) return;
      for (let i = 1; i <= 3; i++) {
        const id = `driver-${i}`;
        const lat = PUB_COORDS.lat + (Math.random() - 0.5) * 0.004;
        const lng = PUB_COORDS.lng + (Math.random() - 0.5) * 0.004;
        const status = ['idle', 'available'][Math.floor(Math.random() * 2)];
        if (client && client.connected) {
          client.publish(`drivers/${id}/location`, JSON.stringify({ lat, lng, status }));
          client.publish(`drivers/${id}/status`, JSON.stringify({ driver: id, status, ts: Date.now() }));
          if (!drivers[id]) {
            drivers[id] = {
              lat, lng,
              data:   { status },
              fcmToken: `simulated-token-${id}`,
              lastActive: Date.now(),
              activeJobId: null
            };
            const color = getColorForDriver(id);
            drivers[id].marker = L.circleMarker([lat, lng], { color, radius: 8 }).addTo(map);
            drivers[id].marker.bindPopup(id);
          }
        }
        updateDriver(id, lat, lng, { status });
      }
      // ‚úÖ OPTIMIZE: Increase sim interval slightly to reduce load
      setTimeout(simLoop, 4000); // Increased from 3000ms
    }

    // === ADMIN ===
    function refreshAllowedDriversList(){
      el.allowedDriversList.innerHTML = allowedDrivers.map(d => `<li>${d}</li>`).join('');
      localStorage.setItem('allowedDrivers', JSON.stringify(allowedDrivers));
    }
    el.adminBtn.onclick = () => el.adminPanel.style.display = 'block';
    el.closeAdmin.onclick = () => el.adminPanel.style.display = 'none';
    el.addDriverBtn.onclick = () => {
      const d = el.adminDriverId.value.trim();
      if (d && !allowedDrivers.includes(d)) {
        allowedDrivers.push(d);
        refreshAllowedDriversList();
      }
    };
    el.removeDriverBtn.onclick = () => {
      const d = el.adminDriverId.value.trim();
      allowedDrivers = allowedDrivers.filter(x => x !== d);
      refreshAllowedDriversList();
    };
    el.allowAllBtn.onclick = () => {
      debugAllowAll = !debugAllowAll;
      el.allowAllBtn.innerText = debugAllowAll ? 'Debug: Disallow All' : 'Debug: Allow All';
      logMsg('Debug allow all = ' + debugAllowAll);
    };

    // === INITIALIZATION ===
    el.orderBtn.onclick = sendOrder;
    el.simulateBtn.onclick = toggleSimDrivers;
    connectMQTT();
    updateJobsTable(); // Use debounced version
    refreshAllowedDriversList();
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }
    el.logOutput.textContent = localStorage.getItem('activityLog') || '';
  </script>
</body>
</html>
