<!doctype html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <title>Black Cab Unite â€” Coventry Rugby (Butts Park Arena) v2.3 (FIXED)</title>
Â  <meta name="viewport" content="width=device-width,initial-scale=1" />
Â  <meta name="theme-color" content="#1f6feb" />
Â  <link rel="manifest" href="manifest.json" />
Â  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
Â  <style>
Â  Â  :root{--accent:#1f6feb;--accent-2:#ff7b00;--bg:#f7fafc;--card:#ffffff;}
Â  Â  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--bg);color:#111;}
Â  Â  .container{display:flex;flex-direction:column;height:100vh;gap:12px;padding:12px;box-sizing:border-box;}
Â  Â  header{display:flex;align-items:center;justify-content:space-between;gap:12px;}
Â  Â  .brand{display:flex;align-items:center;gap:10px;}
Â  Â  .brand h1{margin:0;font-size:20px;letter-spacing:0.5px;}
Â  Â  .tablet-info{text-align:right;font-size:13px;color:#444;}
Â  Â  .main{display:flex;gap:12px;flex:1;min-height:0;}
Â  Â  #map{flex:1;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,0.08);}
Â  Â  .panel{
Â  Â  Â  width:360px;
Â  Â  Â  min-width:260px;
Â  Â  Â  background:var(--card);
Â  Â  Â  border-radius:12px;
Â  Â  Â  box-shadow:0 6px 16px rgba(0,0,0,0.06);
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  overflow:hidden;
Â  Â  }
Â  Â  /* Static Booking Panel */
Â  Â  .booking-panel{
Â  Â  Â  padding:12px;
Â  Â  Â  border-bottom:1px solid #eee;
Â  Â  Â  background:#f9f9f9;
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  gap:8px;
Â  Â  }
Â  Â  .booking-row{
Â  Â  Â  display:flex;
Â  Â  Â  gap:8px;
Â  Â  }
Â  Â  .booking-row input{
Â  Â  Â  width:100%;
Â  Â  Â  padding:8px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  border:1px solid #ccc;
Â  Â  Â  font-size:15px;
Â  Â  }
Â  Â  .order-btn{
Â  Â  Â  background:var(--accent);
Â  Â  Â  color:white;
Â  Â  Â  border:none;
Â  Â  Â  padding:14px;
Â  Â  Â  font-size:17px;
Â  Â  Â  font-weight:600;
Â  Â  Â  border-radius:10px;
Â  Â  Â  cursor:pointer;
Â  Â  Â  width:100%;
Â  Â  Â  box-shadow:0 4px 8px rgba(31,111,235,0.2);
Â  Â  }
Â  Â  .order-btn:active{transform:translateY(1px);}
Â  Â  /* Scrollable Content */
Â  Â  .scroll-content{
Â  Â  Â  flex:1;
Â  Â  Â  overflow-y:auto;
Â  Â  Â  padding:20px;
Â  Â  }
Â  Â  .clear-btn{
Â  Â  Â  background:#dc3545;
Â  Â  Â  color:white;
Â  Â  Â  border:none;
Â  Â  Â  padding:8px 12px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  cursor:pointer;
Â  Â  Â  font-size:13px;
Â  Â  Â  margin-top:8px;
Â  Â  Â  width:100%;
Â  Â  }
Â  Â  .clear-btn:hover{background:#c82333;}
Â  Â  .small{font-size:13px;color:#666;}
Â  Â  .status{padding:10px;border-radius:8px;background:#f2f6ff;color:#08306b;font-weight:600;}
Â  Â  .driver-list{display:flex;flex-direction:column;gap:8px;max-height:140px;overflow:auto;}
Â  Â  .driver-item{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:8px;border-radius:8px;background:#fff;border:1px solid #f0f0f0;}
Â  Â  .small-btn{
Â  Â  Â  border:1px solid #ddd;
Â  Â  Â  background:#fff;
Â  Â  Â  padding:6px 10px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  cursor:pointer;
Â  Â  Â  font-size:13px;
Â  Â  }
Â  Â  table{width:100%;border-collapse:collapse;}
Â  Â  th,td{
Â  Â  Â  padding:8px 4px;
Â  Â  Â  text-align:left;
Â  Â  Â  border-bottom:1px solid #eee;
Â  Â  Â  font-size:14px;
Â  Â  }
Â  Â  th{background:#f0f0f0;font-size:13px;}
Â  Â  tbody td{font-weight:600;}
Â  Â  footer{display:flex;justify-content:space-between;gap:12px;font-size:12px;color:#666;}
Â  Â  .admin-panel{
Â  Â  Â  position:absolute;
Â  Â  Â  top:10px;
Â  Â  Â  left:50%;
Â  Â  Â  transform:translateX(-50%);
Â  Â  Â  background:#fff;
Â  Â  Â  padding:12px;
Â  Â  Â  border-radius:12px;
Â  Â  Â  box-shadow:0 6px 16px rgba(0,0,0,0.1);
Â  Â  Â  z-index:1000;
Â  Â  Â  display:none;
Â  Â  Â  width:300px;
Â  Â  }
Â  Â  .admin-panel h3{margin:0 0 10px 0;font-size:16px;}
Â  Â  .admin-panel .close-btn{float:right;cursor:pointer;color:#555;}
Â  Â  #logPanel{
Â  Â  Â  position:fixed;
Â  Â  Â  bottom:0;
Â  Â  Â  left:0;
Â  Â  Â  right:0;
Â  Â  Â  background:#fff;
Â  Â  Â  border-top:2px solid var(--accent);
Â  Â  Â  box-shadow:0 -4px 16px rgba(0,0,0,0.2);
Â  Â  Â  max-height:0;
Â  Â  Â  overflow:hidden;
Â  Â  Â  transition:max-height 0.4s ease;
Â  Â  Â  padding:0 12px;
Â  Â  Â  z-index: 2000;
Â  Â  }
Â  Â  #logPanel.open{max-height:40vh;padding:12px;}
Â  Â  #logOutput{
Â  Â  Â  font-family:monospace;
Â  Â  Â  font-size:12px;
Â  Â  Â  white-space:pre-wrap;
Â  Â  Â  background:#f9fafc;
Â  Â  Â  padding:8px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  height:100%;
Â  Â  Â  overflow:auto;
Â  Â  }
Â  Â  @media(max-width:900px){
Â  Â  Â  .main{flex-direction:column;}
Â  Â  Â  .panel{width:100%;}
Â  Â  Â  .booking-row input{font-size:14px;}
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="container">
Â  Â  <header>
Â  Â  Â  <div class="brand">
Â  Â  Â  Â  <div style="width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,#004400,#228B22);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;">ğŸ‰</div>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h1>Black Cab Unite â€” Coventry Rugby</h1>
Â  Â  Â  Â  Â  <div class="small">Butts Park Arena</div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div class="tablet-info">
Â  Â  Â  Â  <button class="small-btn" id="logBtn">View Log</button>
Â  Â  Â  Â  <button class="small-btn" id="adminBtn">Admin Panel</button>
Â  Â  Â  </div>
Â  Â  </header>

Â  Â  <div class="main">
Â  Â  Â  <div id="map"></div>
Â  Â  Â  <div class="panel">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="booking-panel">
Â  Â  Â  Â  Â  <div id="connectionStatus" class="status">MQTT: connecting...</div>
Â  Â  Â  Â  Â  <div class="booking-row">
Â  Â  Â  Â  Â  Â  <input type="text" id="customerName" placeholder="Customer name" />
Â  Â  Â  Â  Â  Â  <input type="tel" id="customerPhone" placeholder="+44 7123 456789" />
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <button class="order-btn" id="orderBtn">ORDER TAXI</button>
Â  Â  Â  Â  Â  <button class="clear-btn" id="clearStorageBtn">ğŸ—‘ï¸ Clear All Data</button>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div class="scroll-content">
Â  Â  Â  Â  Â  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
Â  Â  Â  Â  Â  Â  <div style="font-weight:700">Nearby Drivers</div>
Â  Â  Â  Â  Â  Â  <button class="small-btn" id="simulateBtn">Toggle Sim Drivers</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <div class="driver-list" id="driverList"></div>

Â  Â  Â  Â  Â  <div style="margin-top:16px;">
Â  Â  Â  Â  Â  Â  <div style="font-weight:700;margin-bottom:8px;">Current Jobs</div>
Â  Â  Â  Â  Â  Â  <table id="jobsTable">
Â  Â  Â  Â  Â  Â  Â  <thead><tr><th>ID</th><th>Name</th><th>Phone</th><th>Driver</th><th>Status</th></tr></thead>
Â  Â  Â  Â  Â  Â  Â  <tbody></tbody>
Â  Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <footer>
Â  Â  Â  <div>Black Cab Unite â€” Coventry Rugby Club</div>
Â  Â  Â  <div>Topics: pubs/requests/{pub_id} â€¢ drivers/tokens â€¢ jobs/+/status</div>
Â  Â  </footer>

Â  Â  Â  Â  <div class="admin-panel" id="adminPanel">
Â  Â  Â  <span class="close-btn" id="closeAdmin">&times;</span>
Â  Â  Â  <h3>Admin Panel</h3>
Â  Â  Â  <div>
Â  Â  Â  Â  <label>Driver ID:</label>
Â  Â  Â  Â  <input type="text" id="adminDriverId" placeholder="driver-01" />
Â  Â  Â  Â  <button class="small-btn" id="addDriverBtn">Add</button>
Â  Â  Â  Â  <button class="small-btn" id="removeDriverBtn">Remove</button>
Â  Â  Â  </div>
Â  Â  Â  <div style="margin-top:8px;"><button class="small-btn" id="allowAllBtn">Debug: Allow All</button></div>
Â  Â  Â  <div style="margin-top:12px;"><strong>Allowed:</strong><ul id="allowedDriversList"></ul></div>
Â  Â  </div>

Â  Â  Â  Â  <div id="logPanel">
Â  Â  Â  <h3 style="margin:0 0 8px 0;">ğŸ“‹ Activity Log</h3>
Â  Â  Â  <div id="logOutput"></div>
Â  Â  Â  <button class="small-btn" onclick="clearLog()">Clear Log</button>
Â  Â  </div>

Â  </div>

Â  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
Â  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
Â  <script>
Â  Â  // === CONFIG ===
Â  Â  const PUB_ID = 'coventry-rugby-butts-park';
Â  Â  const PUB_NAME = 'Coventry Rugby â€” Butts Park Arena';
Â  Â  const PUB_COORDS = { lat: 52.407234, lng: -1.525504 };
Â  Â  const BIDDING_WINDOW_MS = 60_000; // 60 seconds
Â  Â  const OUT_OF_DATE_THRESHOLD_MS = 60_000; // 60 seconds for freshness check

Â  Â  // ===== FCM PUSH VIA CLOUD FUNCTION (HTTP) =====
Â  Â  const CLOUD_FUNCTION_URL = 'https://europe-west2-cabunite.cloudfunctions.net/sendJobAlertHttp';

Â  Â  async function sendPushToDriver(driverId, fcmToken, jobId, reason) {
Â  Â  Â  if (!driverId || typeof driverId !== 'string' || driverId.trim() === '') {
Â  Â  Â  Â  logMsg(`âš ï¸ Skip push: invalid driverId "${driverId}"`);
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  driverId = driverId.trim();

Â  Â  Â  if (!fcmToken) {
Â  Â  Â  Â  logMsg(`âŒ No FCM token for ${driverId}`);
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  try {
Â  Â  Â  Â  logMsg(`ğŸ“¤ Sending push to ${driverId}...`);
Â  Â  Â  Â  const response = await fetch(CLOUD_FUNCTION_URL, {
Â  Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  Â  Â  body: JSON.stringify({ driverId, fcmToken, jobId, reason })
Â  Â  Â  Â  });

Â  Â  Â  Â  const data = await response.json();

Â  Â  Â  Â  if (response.ok && data.messageId) {
Â  Â  Â  Â  Â  logMsg(`âœ… Push sent to ${driverId} (${data.messageId})`);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  logMsg(`âŒ Push failed for ${driverId}: ${data.error || JSON.stringify(data)}`);
Â  Â  Â  Â  }
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  logMsg(`âŒ Push error for ${driverId}: ${err.message}`);
Â  Â  Â  }
Â  Â  }

Â  Â  // === SAFE JSON PARSING ===
Â  Â  function safeParseJson(key, fallback) {
Â  Â  Â  const item = localStorage.getItem(key);
Â  Â  Â  if (item === null || item === '') return fallback;
Â  Â  Â  try {
Â  Â  Â  Â  return JSON.parse(item);
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  console.warn(`Invalid JSON in localStorage.${key}:`, item);
Â  Â  Â  Â  localStorage.removeItem(key);
Â  Â  Â  Â  return fallback;
Â  Â  Â  }
Â  Â  }

Â  Â  // === STATE ===
Â  Â  let drivers = {}; // Fix: Initialize as an empty object
Â  Â  const pendingJobs = {}; 
Â  Â  let visibleJobs = safeParseJson('visibleJobs', {});
Â  Â  let allowedDrivers = safeParseJson('allowedDrivers', []);
Â  Â  let debugAllowAll = false;
Â  Â  let simActive = false;

Â  Â  // === DOM ELEMENTS ===
Â  Â  const el = {
Â  Â  Â  connectionStatus: document.getElementById('connectionStatus'),
Â  Â  Â  driverList: document.getElementById('driverList'),
Â  Â  Â  customerName: document.getElementById('customerName'),
Â  Â  Â  customerPhone: document.getElementById('customerPhone'),
Â  Â  Â  orderBtn: document.getElementById('orderBtn'),
Â  Â  Â  simulateBtn: document.getElementById('simulateBtn'),
Â  Â  Â  jobsTable: document.querySelector("#jobsTable tbody"),
Â  Â  Â  adminPanel: document.getElementById('adminPanel'),
Â  Â  Â  closeAdmin: document.getElementById('closeAdmin'),
Â  Â  Â  adminBtn: document.getElementById('adminBtn'),
Â  Â  Â  adminDriverId: document.getElementById('adminDriverId'),
Â  Â  Â  addDriverBtn: document.getElementById('addDriverBtn'),
Â  Â  Â  removeDriverBtn: document.getElementById('removeDriverBtn'),
Â  Â  Â  allowAllBtn: document.getElementById('allowAllBtn'),
Â  Â  Â  allowedDriversList: document.getElementById('allowedDriversList'),
Â  Â  Â  logBtn: document.getElementById('logBtn'),
Â  Â  Â  logPanel: document.getElementById('logPanel'),
Â  Â  Â  logOutput: document.getElementById('logOutput'),
Â  Â  Â  clearStorageBtn: document.getElementById('clearStorageBtn')
Â  Â  };

Â  Â  // === LOGGING ===
Â  Â  function logMsg(msg){
Â  Â  Â  const ts = new Date().toLocaleTimeString();
Â  Â  Â  const entry = `[${ts}] ${msg}\n`;
Â  Â  Â  // Use an in-memory array for logs to prevent excessive localStorage writes/reads, then update DOM/LocalStorage.
Â  Â  Â  // For simplicity, we'll keep the original localStorage log storage but make it more performant by only reading/writing the whole thing less frequently.
Â  Â  Â 
Â  Â  Â  // Simple logging to DOM (performance compromise for demo)
Â  Â  Â  el.logOutput.textContent += entry;
Â  Â  Â  el.logOutput.scrollTop = el.logOutput.scrollHeight; // Auto-scroll
Â  Â  Â Â 
Â  Â  Â  // Persist to localStorage less often to prevent slow-down, or use a log buffer.
Â  Â  Â  // For now, stick to original logic:
Â  Â  Â  const logs = localStorage.getItem('activityLog') || '';
Â  Â  Â  localStorage.setItem('activityLog', logs + entry);
Â  Â  }

Â  Â  el.logBtn.onclick = () => el.logPanel.classList.toggle('open');
Â  Â  function clearLog(){ localStorage.removeItem('activityLog'); el.logOutput.textContent = ''; }

Â  Â  // === CLEAR STORAGE BUTTON ===
Â  Â  el.clearStorageBtn.onclick = () => {
Â  Â  Â  if (confirm("âš ï¸ Clear ALL data? This will remove jobs, drivers, logs, and settings.")) {
Â  Â  Â  Â  localStorage.clear();
Â  Â  Â  Â  visibleJobs = {};
Â  Â  Â  Â  // Reset drivers object completely and remove all markers from map
Â  Â  Â  Â  Object.values(drivers).forEach(d => { if(d.marker) map.removeLayer(d.marker); });
Â  Â  Â  Â  drivers = {}; 
Â  Â  Â  Â  // Clear pending jobs timeouts
Â  Â  Â  Â  Object.values(pendingJobs).forEach(p => clearTimeout(p.timeoutId));
Â  Â  Â  Â  pendingJobs = {};
Â  Â  Â  Â  updateJobsTable();
Â  Â  Â  Â  el.driverList.innerHTML = '';
Â  Â  Â  Â  clearLog();
Â  Â  Â  Â  logMsg("ğŸ—‘ï¸ All local storage cleared and state reset.");
Â  Â  Â  }
Â  Â  };

Â  Â  // === MAP SETUP ===
Â  Â  const map = L.map('map').setView([PUB_COORDS.lat, PUB_COORDS.lng], 15);
Â  Â  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
Â  Â  L.marker([PUB_COORDS.lat, PUB_COORDS.lng]).addTo(map).bindPopup(PUB_NAME);

Â  Â  // === HELPERS ===
Â  Â  function distanceMeters(a, b) {
Â  Â  Â  const R = 6371000;
Â  Â  Â  const toRad = x => x * Math.PI / 180;
Â  Â  Â  const Ï†1 = toRad(a.lat), Ï†2 = toRad(b.lat);
Â  Â  Â  const Î”Ï† = toRad(b.lat - a.lat), Î”Î» = toRad(b.lng - a.lng);
Â  Â  Â  const a_ = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î»/2)**2;
Â  Â  Â  return R * 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
Â  Â  }

Â  Â  // === DRIVER MANAGEMENT ===
Â  Â  // Fixed: Ensure drivers[id].data is an object and merge meta correctly.
Â  Â  function updateDriver(id, lat, lng, meta = {}) {
Â  Â  Â  if (!id) return;
Â  Â  Â Â 
Â  Â  Â  // Initialize or retrieve driver state
Â  Â  Â  if (!drivers[id]) {
Â  Â  Â  Â  drivers[id] = { lat: PUB_COORDS.lat, lng: PUB_COORDS.lng, data: { status: 'idle' }, fcmToken: null, lastActive: Date.now(), marker: null };
Â  Â  Â  Â  const color = getColorForDriver(id);
Â  Â  Â  Â  drivers[id].marker = L.circleMarker([lat, lng], { color, radius: 8 }).addTo(map).bindPopup(id);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  // Update location and metadata
Â  Â  Â  drivers[id].lat = lat;
Â  Â  Â  drivers[id].lng = lng;
Â  Â  Â  drivers[id].data = { ...drivers[id].data, ...meta }; // Merge existing data with new meta
Â  Â  Â  drivers[id].lastActive = Date.now();
Â  Â  Â  
Â  Â  Â  if (drivers[id].marker) {
Â  Â  Â  Â  drivers[id].marker.setLatLng([lat, lng]);
Â  Â  Â  Â  drivers[id].marker.setPopupContent(`${id} (${drivers[id].data?.status || 'idle'})`);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  refreshDriverList();
Â  Â  }

Â  Â  function refreshDriverList() {
Â  Â  Â  el.driverList.innerHTML = '';
Â  Â  Â  // Sort drivers by distance for better visibility
Â  Â  Â  const sortedDrivers = Object.entries(drivers).map(([id, d]) => ({
Â  Â  Â  Â  id,
Â  Â  Â  Â  ...d,
Â  Â  Â  Â  dist: distanceMeters(d, PUB_COORDS)
Â  Â  Â  })).sort((a, b) => a.dist - b.dist);

Â  Â  Â  sortedDrivers.forEach(d => {
Â  Â  Â  Â  const div = document.createElement('div');
Â  Â  Â  Â  div.className = 'driver-item';
Â  Â  Â  Â  div.innerHTML = `
Â  Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  Â  <b>${d.id}</b>
Â  Â  Â  Â  Â  Â  <div class="small" style="color:${d.data?.status === 'allocated' ? 'var(--accent-2)' : '#666'}">${d.data?.status || 'idle'}</div>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <div>${d.dist < 1000 ? d.dist.toFixed(0) + 'm' : (d.dist / 1000).toFixed(1) + 'km'}</div>
Â  Â  Â  Â  `;
Â  Â  Â  Â  el.driverList.appendChild(div);
Â  Â  Â  });
Â  Â  }

Â  Â  function getColorForDriver(driverId) {
Â  Â  Â  let hash = 0;
Â  Â  Â  for (let i = 0; i < driverId.length; i++) {
Â  Â  Â  Â  hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
Â  Â  Â  }
Â  Â  Â  const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
Â  Â  Â  return "#" + "00000".substring(0, 6 - c.length) + c;
Â  Â  }

Â  Â  // === MQTT ===
Â  Â  let client = null;
Â  Â  function connectMQTT(){
Â  Â  Â  // FIX: Status element is now permanently in HTML structure (see L182)
Â  Â  Â  el.connectionStatus.textContent = 'MQTT: connecting...';
Â  Â  Â Â 
Â  Â  Â  client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt', { connectTimeout: 4000, reconnectPeriod: 1000, clientId: `dispatch-pub-${PUB_ID}-${Date.now()}` });
Â  Â  Â  
Â  Â  Â  client.on('connect', () => {
Â  Â  Â  Â  el.connectionStatus.textContent = 'MQTT: connected';
Â  Â  Â  Â  logMsg('âœ… Connected to MQTT');
Â  Â  Â  Â  client.subscribe(`drivers/+/location`);
Â  Â  Â  Â  client.subscribe(`drivers/+/status`); 
Â  Â  Â  Â  client.subscribe(`jobs/+/status`);
Â  Â  Â  Â  client.subscribe('drivers/tokens');
Â  Â  Â  Â  client.subscribe(`pubs/requests/${PUB_ID}`); 
Â  Â  Â  Â  resendOfflineJobs();
Â  Â  Â  });

Â  Â  Â  client.on('error', (err) => {
Â  Â  Â  Â  el.connectionStatus.textContent = `MQTT: Error (${err.message})`;
Â  Â  Â  Â  logMsg(`âŒ MQTT Error: ${err.message}`);
Â  Â  Â  });

Â  Â  Â  client.on('close', () => {
Â  Â  Â  Â  el.connectionStatus.textContent = 'MQTT: Disconnected';
Â  Â  Â  Â  logMsg('âš ï¸ MQTT Disconnected');
Â  Â  Â  });

Â  Â  Â  client.on('message', (topic, msg) => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  const data = JSON.parse(msg.toString());
Â  Â  Â  Â  Â  logMsg(`ğŸ“¡ ${topic} -> ${JSON.stringify(data)}`); 

Â  Â  Â  Â  Â  if (topic.endsWith('/location')) {
Â  Â  Â  Â  Â  Â  const id = topic.split('/')[1];
Â  Â  Â  Â  Â  Â  updateDriver(id, data.lat, data.lng, data);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // FCM TOKEN HANDLING
Â  Â  Â  Â  Â  if (topic === 'drivers/tokens') {
Â  Â  Â  Â  Â  Â  const { driverId, fcmToken } = data;
Â  Â  Â  Â  Â  Â  if (driverId && fcmToken) {
Â  Â  Â  Â  Â  Â  Â  if (!drivers[driverId]) {
Â  Â  Â  Â  Â  Â  Â  Â  // If driver doesn't exist, initialize with a token (location will follow)
Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  lat: PUB_COORDS.lat, lng: PUB_COORDS.lng, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  data: { status: 'idle' }, // Fix: ensure data structure is correct
Â  Â  Â  Â  Â  Â  Â  Â  Â  fcmToken: fcmToken,
Â  Â  Â  Â  Â  Â  Â  Â  Â  lastActive: Date.now(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  marker: null // Marker will be added/updated by updateDriver when location comes in
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].fcmToken = fcmToken;
Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].lastActive = Date.now();
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  logMsg(`âœ… FCM token received for ${driverId}`);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // CRITICAL: DRIVER STATUS CHANGES
Â  Â  Â  Â  Â  if (topic.startsWith("drivers/") && topic.endsWith("/status")) {
Â  Â  Â  Â  Â  Â  const driverId = topic.split('/')[1];
Â  Â  Â  Â  Â  Â  if (driverId === 'tokens' || data.driver !== driverId) return;

Â  Â  Â  Â  Â  Â  // 1. Update local driver status and ensure the driver object exists
Â  Â  Â  Â  Â  Â  if (!drivers[driverId]) {
Â  Â  Â  Â  Â  Â  Â  // If status update arrives before location/token, initialize minimally
Â  Â  Â  Â  Â  Â  Â  drivers[driverId] = { lat: PUB_COORDS.lat, lng: PUB_COORDS.lng, data: {}, fcmToken: null, lastActive: Date.now(), marker: null };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  drivers[driverId].data.status = data.status;
Â  Â  Â  Â  Â  Â  drivers[driverId].data.activeJobId = data.activeJobId || null; // CRITICAL: Track the job the driver is locked to
Â  Â  Â  Â  Â  Â  drivers[driverId].lastActive = data.ts || Date.now();
Â  Â  Â  Â  Â  Â  refreshDriverList();
Â  Â  Â  Â  Â  Â  logMsg(`ğŸ“Š Driver ${driverId} status updated to: ${data.status} (Job Lock: ${data.activeJobId || 'none'})`);

Â  Â  Â  Â  Â  Â  // 2. Check for Re-allocation Trigger (Allocated Driver goes Offline/Busy/Cancels)
Â  Â  Â  Â  Â  Â  const assignedJobId = Object.keys(visibleJobs).find(jobId => {
Â  Â  Â  Â  Â  Â  Â  const job = visibleJobs[jobId];
Â  Â  Â  Â  Â  Â  Â  // Only re-allocate if the job is ALREADY allocated/on_route AND the driver is the one assigned
Â  Â  Â  Â  Â  Â  Â  return job.driver === driverId && (job.status === 'allocated' || job.status === 'on_route');
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  if (assignedJobId) {
Â  Â  Â  Â  Â  Â  Â  // Re-allocate if the driver's reported status suggests they cannot service the job
Â  Â  Â  Â  Â  Â  Â  if (data.status === 'busy' || data.status === 'offline' || data.status === 'available' || data.status === 'idle') {
Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`âš ï¸ Driver ${driverId} (allocated to job ${assignedJobId}) changed status to ${data.status}. Triggering Re-allocation.`);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Send 'lost' result to all previous bidders to clear their locks (optional, but clean)
Â  Â  Â  Â  Â  Â  Â  Â  const job = visibleJobs[assignedJobId];
Â  Â  Â  Â  Â  Â  Â  Â  if (job.bidderList) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  job.bidderList.forEach(bidderId => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (bidderId !== driverId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`jobs/${assignedJobId}/result/${bidderId}`, JSON.stringify({ result: "re_bidding_due_to_failure" }));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  reAllocateJob(job);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // JOB STATUS UPDATES (BIDDING, COMPLETION, ETC.)
Â  Â  Â  Â  Â  if (topic.startsWith('jobs/') && topic.endsWith('/status')) {
Â  Â  Â  Â  Â  Â  const jobId = topic.split('/')[1];
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Bid message logic
Â  Â  Â  Â  Â  Â  if (visibleJobs[jobId]) {
Â  Â  Â  Â  Â  Â  Â  const job = visibleJobs[jobId];
Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  // Bid received
Â  Â  Â  Â  Â  Â  Â  if (data.status === 'bidding' && data.driver) {
Â  Â  Â  Â  Â  Â  Â  Â  const driverId = data.driver;
Â  Â  Â  Â  Â  Â  Â  Â  const driverState = drivers[driverId];

Â  Â  Â  Â  Â  Â  Â  Â  // CRITICAL FIX: Job Lockout Check (Driver can only bid on ONE job at a time)
Â  Â  Â  Â  Â  Â  Â  Â  if (driverState && driverState.data.activeJobId && driverState.data.activeJobId !== jobId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`âŒ BID REJECTED: ${driverId} already locked to ${driverState.data.activeJobId}.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Optionally publish rejection result to the driver for client-side feedback
Â  Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "rejected_multi_bid", message: `You are locked to job ${driverState.data.activeJobId}` }));
Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (!pendingJobs[jobId]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // First bid starts the timer
Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingJobs[jobId] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...job,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bidCount: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bids: {},
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timeoutId: setTimeout(() => finalizeBidding(jobId), BIDDING_WINDOW_MS)
Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  // CRITICAL: Update the job status immediately upon first bid
Â  Â  Â  Â  Â  Â  Â  Â  Â  job.status = 'bidding';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (!pendingJobs[jobId].bids[driverId]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingJobs[jobId].bidCount += 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingJobs[jobId].bids[driverId] = { lat: data.lat, lng: data.lng, timestamp: data.ts };
Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Lock the driver to this job
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (driverState) driverState.data.activeJobId = jobId; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  job.status = `Bidding (${pendingJobs[jobId].bidCount})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  updateJobsTable();
Â  Â  Â  Â  Â  Â  Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`ğŸ“¥ Bid #${pendingJobs[jobId].bidCount} for ${jobId} from ${driverId}. Driver locked.`);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  // Non-bid status updates (on_route, arrived, completed, cancelled)
Â  Â  Â  Â  Â  Â  Â  if (data.status !== 'bidding') {
Â  Â  Â  Â  Â  Â  Â  Â  job.status = data.status;
Â  Â  Â  Â  Â  Â  Â  Â  job.driver = data.driver || job.driver || '-';
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // CRITICAL: Unlock driver upon completion or cancellation
Â  Â  Â  Â  Â  Â  Â  Â  if (data.status === 'completed' || data.status === 'cancelled') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (data.driver && drivers[data.driver]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drivers[data.driver].data.activeJobId = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`ğŸ”“ Driver ${data.driver} unlocked from job ${jobId}.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  updateJobsTable();
Â  Â  Â  Â  Â  Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch(e) { console.warn("MQTT parse error:", e); }
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to re-allocate a job
Â  Â  function reAllocateJob(job) {
Â  Â  Â  logMsg(`ğŸ”„ Re-allocating job ${job.job}...`);
Â  Â  Â  
Â  Â  Â  // 1. Reset job status and driver info
Â  Â  Â  job.status = 're-queued'; // New status for clarity
Â  Â  Â  job.driver = '-';
Â  Â  Â  job.bidderList = []; // Reset bidder list
Â  Â  Â  updateJobsTable();
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  Â  
Â  Â  Â  // 2. Clear any existing pending job timer if it exists (for safety)
Â  Â  Â  if (pendingJobs[job.job]) {
Â  Â  Â  Â  clearTimeout(pendingJobs[job.job].timeoutId);
Â  Â  Â  Â  delete pendingJobs[job.job];
Â  Â  Â  Â  logMsg(`ğŸ—‘ï¸ Cleared pending job timer for ${job.job}`);
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  // 3. Publish job again to pubs/requests/
Â  Â  Â  client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(job));
Â  Â  Â  logMsg(`ğŸ“¤ Re-sent job ${job.job} for bidding.`);
Â  Â  Â  
Â  Â  Â  // 4. Send FCM pushes again to eligible drivers (same logic as sendOrder)
Â  Â  Â  const now = Date.now();
Â  Â  Â  Object.entries(drivers).forEach(([id, driver]) => {
Â  Â  Â  Â  if (!id || !driver.fcmToken) return;
Â  Â  Â  Â  const isAllowed = debugAllowAll || allowedDrivers.includes(id);
Â  Â  Â  Â  const isFresh = (now - (driver.lastActive || 0)) < OUT_OF_DATE_THRESHOLD_MS;
Â  Â  Â  Â  const inRange = distanceMeters(driver, PUB_COORDS) <= 10_000;
Â  Â  Â  Â  // Allow to bid only if available/idle AND not currently locked to another active job
Â  Â  Â  Â  const isActive = (driver.data?.status === 'available' || driver.data?.status === 'idle');
Â  Â  Â  Â  const isNotLocked = !driver.data?.activeJobId || driver.data.activeJobId === job.job; // Must be unlocked or locked to THIS job (only happens if the job was lost but not unlocked)
Â  Â  Â  Â Â 
Â  Â  Â  Â  let reason = 'eligible';
Â  Â  Â  Â  if (!isAllowed) reason = 'not_allowed';
Â  Â  Â  Â  else if (!isFresh) reason = 'gps_old';
Â  Â  Â  Â  else if (!inRange) reason = 'out_of_range';
Â  Â  Â  Â  else if (!isActive) reason = 'not_idle_or_available';
Â  Â  Â  Â  else if (!isNotLocked) reason = 'locked_to_other_job';
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (reason === 'eligible') {
Â  Â  Â  Â  Â  Â  sendPushToDriver(id, driver.fcmToken, job.job, 'reallocated_job');
Â  Â  Â  Â  Â  Â  job.bidderList.push(id); // Re-track eligible drivers
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  logMsg(`Skip re-push to ${id}: ${reason}`);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }

Â  Â  // === JOBS ===
Â  Â  function sendOrder() {
Â  Â  Â  const name = el.customerName.value.trim();
Â  Â  Â  const phone = el.customerPhone.value.trim();
Â  Â  Â  if (!name) return alert("Enter customer name");
Â  Â  Â  if (!phone) return alert("Enter customer phone");

Â  Â  Â  const jobId = 'job-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 2); // More unique ID
Â  Â  Â  const job = {
Â  Â  Â  Â  job: jobId,
Â  Â  Â  Â  pubName: PUB_NAME,
Â  Â  Â  Â  customerName: name,
Â  Â  Â  Â  customerPhone: phone,
Â  Â  Â  Â  lat: PUB_COORDS.lat,
Â  Â  Â  Â  lng: PUB_COORDS.lng,
Â  Â  Â  Â  ts: Date.now(),
Â  Â  Â  Â  status: 'queued',
Â  Â  Â  Â  driver: '-',
Â  Â  Â  Â  bidderList: [] // Store list of drivers notified
Â  Â  Â  };

Â  Â  Â  visibleJobs = { [jobId]: job, ...visibleJobs }; 
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  Â  updateJobsTable();

Â  Â  Â  if (client && client.connected) {
Â  Â  Â  Â  client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(job));
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Send FCM pushes
Â  Â  Â  Â  const now = Date.now();
Â  Â  Â  Â  Object.entries(drivers).forEach(([id, driver]) => {
Â  Â  Â  Â  Â  if (!id || !driver.fcmToken) return;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  const isAllowed = debugAllowAll || allowedDrivers.includes(id);
Â  Â  Â  Â  Â  const isFresh = (now - (driver.lastActive || 0)) < OUT_OF_DATE_THRESHOLD_MS;
Â  Â  Â  Â  Â  const inRange = distanceMeters(driver, PUB_COORDS) <= 10_000;
Â  Â  Â  Â  Â  // New Job: Only notify if status is available/idle AND NOT locked to another job
Â  Â  Â  Â  Â  const isActive = (driver.data?.status === 'available' || driver.data?.status === 'idle');
Â  Â  Â  Â  Â  const isNotLocked = !driver.data?.activeJobId; // Must be NULL

Â  Â  Â  Â  Â  let reason = 'eligible';
Â  Â  Â  Â  Â  if (!isAllowed) reason = 'not_allowed';
Â  Â  Â  Â  Â  else if (!isFresh) reason = 'gps_old';
Â  Â  Â  Â  Â  else if (!inRange) reason = 'out_of_range';
Â  Â  Â  Â  Â  else if (!isActive) reason = 'not_idle_or_available';
Â  Â  Â  Â  Â  else if (!isNotLocked) reason = 'locked_to_other_job';
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (reason === 'eligible') {
Â  Â  Â  Â  Â  Â  Â  sendPushToDriver(id, driver.fcmToken, jobId, reason);
Â  Â  Â  Â  Â  Â  Â  job.bidderList.push(id); 
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  logMsg(`Skip push to ${id}: ${reason}`);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  logMsg('ğŸ“¤ Sent job ' + jobId);
Â  Â  Â  } else {
Â  Â  Â  Â  const offlineQueue = safeParseJson('offlineQueue', []);
Â  Â  Â  Â  offlineQueue.push(job);
Â  Â  Â  Â  localStorage.setItem('offlineQueue', JSON.stringify(offlineQueue));
Â  Â  Â  Â  logMsg('ğŸ“¦ Stored offline job ' + jobId);
Â  Â  Â  }
Â  Â  }

Â  Â  function resendOfflineJobs() {
Â  Â  Â  const offlineQueue = safeParseJson('offlineQueue', []);
Â  Â  Â  if (offlineQueue.length === 0) return;
Â  Â  Â  
Â  Â  Â  // FIX: Re-insert offline jobs into visibleJobs and re-send notifications/MQTT
Â  Â  Â  offlineQueue.forEach(j => {
Â  Â  Â  Â  visibleJobs = { [j.job]: j, ...visibleJobs };
Â  Â  Â  Â  client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(j));
Â  Â  Â  Â  logMsg('â˜ï¸ Resent job ' + j.job);
Â  Â  Â  Â  // Note: FCM pushes are NOT re-sent here. The initial push has likely failed/expired. 
Â  Â  Â  Â  // The primary system behavior should rely on the MQTT publish and driver clients being online to receive it.
Â  Â  Â  Â  // If the driver misses the MQTT for a queued job, they will only see it if it's re-allocated later.
Â  Â  Â  });
Â  Â  Â  localStorage.setItem('offlineQueue', '[]');
Â  Â  Â  updateJobsTable();
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  }

Â  Â  function updateJobsTable() {
Â  Â  Â  el.jobsTable.innerHTML = '';
Â  Â  Â  Object.entries(visibleJobs).forEach(([id, j]) => {
Â  Â  Â  Â  const tr = document.createElement('tr');
Â  Â  Â  Â  tr.innerHTML = `
Â  Â  Â  Â  Â  <td>${id.substring(4)}</td>
Â  Â  Â  Â  Â  <td>${j.customerName || '-'}</td>
Â  Â  Â  Â  Â  <td>${j.customerPhone || '-'}</td>
Â  Â  Â  Â  Â  <td>${j.driver || '-'}</td>
Â  Â  Â  Â  Â  <td style="color:${j.status.includes('Bidding') ? 'var(--accent)' : j.status === 'allocated' || j.status === 'on_route' ? 'var(--accent-2)' : '#000'}">${j.status}</td>
Â  Â  Â  Â  `;
Â  Â  Â  Â  el.jobsTable.appendChild(tr);
Â  Â  Â  });
Â  Â  }

Â  Â  // === FINALIZE BIDDING (60s) ===
Â  Â  function finalizeBidding(jobId) {
Â  Â  Â  const job = pendingJobs[jobId];
Â  Â  Â  if (!job) return;

Â  Â  Â  let winner = null;
Â  Â  Â  const bids = Object.entries(job.bids || {});
Â  Â  Â  const jobCoords = {lat: job.lat, lng: job.lng};

Â  Â  Â  if (bids.length > 0) {
Â  Â  Â  Â  // Filter for only AVAILABLE/IDLE drivers who are NOT currently allocated to another job
Â  Â  Â  Â  const validBids = bids.filter(([id]) => {
Â  Â  Â  Â  Â  const d = drivers[id];
Â  Â  Â  Â  Â  // The driver must be known, available/idle, and not locked to another job
Â  Â  Â  Â  Â  return d && (d.data?.status === 'idle' || d.data?.status === 'available') && !d.data?.activeJobId;
Â  Â  Â  Â  });

Â  Â  Â  Â  if (validBids.length > 0) {
Â  Â  Â  Â  Â  // Sort by distance (closest wins)
Â  Â  Â  Â  Â  validBids.sort(([, a], [, b]) => {
Â  Â  Â  Â  Â  Â  const distA = distanceMeters(a, jobCoords);
Â  Â  Â  Â  Â  Â  const distB = distanceMeters(b, jobCoords);
Â  Â  Â  Â  Â  Â  return distA - distB;
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  winner = validBids[0][0];
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // 1. Handle Winner or No Winner
Â  Â  Â  if (winner) {
Â  Â  Â  Â  visibleJobs[jobId].status = 'allocated';
Â  Â  Â  Â  visibleJobs[jobId].driver = winner;
Â  Â  Â  Â  
Â  Â  Â  Â  // CRITICAL: Lock the winning driver to this job
Â  Â  Â  Â  if (drivers[winner]) {
Â  Â  Â  Â  Â  drivers[winner].data.activeJobId = jobId;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${winner}`, JSON.stringify({ result: "won" }));
Â  Â  Â  Â  logMsg(`ğŸ† ${jobId} â†’ ${winner} (Locked)`);
Â  Â  Â  } else {
Â  Â  Â  Â  visibleJobs[jobId].status = 'no_bids';
Â  Â  Â  Â  visibleJobs[jobId].driver = '-';
Â  Â  Â  Â  logMsg(`â° ${jobId}: no valid bids or all bidders became unavailable.`);
Â  Â  Â  }

Â  Â  Â  // 2. Send Results to all Bidders and Unlock Losers/Invalid Bidders
Â  Â  Â  bids.forEach(([driverId]) => {
Â  Â  Â  Â  const driverState = drivers[driverId];
Â  Â  Â  Â  if (driverId !== winner) {
Â  Â  Â  Â  Â  // Send 'lost' message
Â  Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "lost" }));
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // Unlock the losing driver
Â  Â  Â  Â  Â  if (driverState && driverState.data.activeJobId === jobId) {
Â  Â  Â  Â  Â  Â  driverState.data.activeJobId = null;
Â  Â  Â  Â  Â  Â  logMsg(`ğŸ”“ Driver ${driverId} unlocked (Lost bid).`);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  delete pendingJobs[jobId];
Â  Â  Â  updateJobsTable();
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  }

Â  Â  // === SIMULATION ===
Â  Â  function toggleSimDrivers(){
Â  Â  Â  simActive = !simActive;
Â  Â  Â  el.simulateBtn.innerText = simActive ? 'Stop Sim Drivers' : 'Toggle Sim Drivers';
Â  Â  Â  if (simActive) simLoop();
Â  Â  Â  else logMsg("ğŸ›‘ Stopped simulation drivers.");
Â  Â  }
Â  Â  function simLoop(){
Â  Â  Â  if (!simActive) return;
Â  Â  Â  for (let i = 1; i <= 3; i++) {
Â  Â  Â  Â  const id = `driver-${i}`;
Â  Â  Â  Â  const lat = PUB_COORDS.lat + (Math.random() - 0.5) * 0.004;
Â  Â  Â  Â  const lng = PUB_COORDS.lng + (Math.random() - 0.5) * 0.004;
Â  Â  Â  Â  
Â  Â  Â  Â  // FIX: Ensure driver data exists before checking for marker or token
Â  Â  Â  Â  if (!drivers[id]) {
Â  Â  Â  Â  Â  drivers[id] = {
Â  Â  Â  Â  Â  Â  lat: PUB_COORDS.lat, lng: PUB_COORDS.lng, 
Â  Â  Â  Â  Â  Â  data: { status: 'idle', activeJobId: null },
Â  Â  Â  Â  Â  Â  fcmToken: `simulated-token-${id}`,
Â  Â  Â  Â  Â  Â  lastActive: Date.now(),
Â  Â  Â  Â  Â  Â  marker: null
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  // Simulate adding marker to map for the first time
Â  Â  Â  Â  Â  const color = getColorForDriver(id);
Â  Â  Â  Â  Â  drivers[id].marker = L.circleMarker([lat, lng], { color, radius: 8 }).addTo(map).bindPopup(id);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // Update location via central function
Â  Â  Â  Â  updateDriver(id, lat, lng, { status: 'idle' }); 
Â  Â  Â  Â  
Â  Â  Â  Â  if (client && client.connected) {
Â  Â  Â  Â  Â  // Simulate MQTT publishes for location and status
Â  Â  Â  Â  Â  client.publish(`drivers/${id}/location`, JSON.stringify({ lat, lng, status: 'idle' }));
Â  Â  Â  Â  Â  // Simulate status update, including activeJobId for logic checks
Â  Â  Â  Â  Â  client.publish(`drivers/${id}/status`, JSON.stringify({ 
Â  Â  Â  Â  Â  Â  driver: id, 
Â  Â  Â  Â  Â  Â  status: 'idle', 
Â  Â  Â  Â  Â  Â  ts: Date.now(),
Â  Â  Â  Â  Â  Â  activeJobId: drivers[id].data.activeJobId // Send current lock status
Â  Â  Â  Â  Â  })); 
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  setTimeout(simLoop, 3000);
Â  Â  }

Â  Â  // === ADMIN ===
Â  Â  function refreshAllowedDriversList(){
Â  Â  Â  el.allowedDriversList.innerHTML = allowedDrivers.map(d => `<li>${d}</li>`).join('');
Â  Â  Â  localStorage.setItem('allowedDrivers', JSON.stringify(allowedDrivers));
Â  Â  }
Â  Â  el.adminBtn.onclick = () => el.adminPanel.style.display = 'block';
Â  Â  el.closeAdmin.onclick = () => el.adminPanel.style.display = 'none';
Â  Â  el.addDriverBtn.onclick = () => {
Â  Â  Â  const d = el.adminDriverId.value.trim();
Â  Â  Â  if (d && !allowedDrivers.includes(d)) {
Â  Â  Â  Â  allowedDrivers.push(d);
Â  Â  Â  Â  refreshAllowedDriversList();
Â  Â  Â  }
Â  Â  };
Â  Â  el.removeDriverBtn.onclick = () => {
Â  Â  Â  const d = el.adminDriverId.value.trim();
Â  Â  Â  allowedDrivers = allowedDrivers.filter(x => x !== d);
Â  Â  Â  refreshAllowedDriversList();
Â  Â  };
Â  Â  el.allowAllBtn.onclick = () => {
Â  Â  Â  debugAllowAll = !debugAllowAll;
Â  Â  Â  el.allowAllBtn.innerText = debugAllowAll ? 'Debug: Disallow All' : 'Debug: Allow All';
Â  Â  Â  logMsg('Debug allow all = ' + debugAllowAll);
Â  Â  };

Â  Â  // === INITIALIZATION ===
Â  Â  el.orderBtn.onclick = sendOrder;
Â  Â  el.simulateBtn.onclick = toggleSimDrivers;
Â  Â  
Â  Â  // Removed duplicated/incorrect status element creation (line 320 in original)
Â  Â  // el.connectionStatus.textContent is set at start of connectMQTT()

Â  Â  connectMQTT();
Â  Â  updateJobsTable();
Â  Â  refreshAllowedDriversList();
Â  Â  if ('serviceWorker' in navigator) {
Â  Â  Â  navigator.serviceWorker.register('service-worker.js');
Â  Â  }
Â  Â  el.logOutput.textContent = localStorage.getItem('activityLog') || '';
Â  </script>
</body>
</html>
