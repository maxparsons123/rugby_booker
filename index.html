<!doctype html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <title>Black Cab Unite â€” Coventry Rugby (Butts Park Arena) v2.6 (Final Secured)</title>
Â  <meta name="viewport" content="width=device-width,initial-scale=1" />
Â  <meta name="theme-color" content="#1f6feb" />
Â  <link rel="manifest" href="manifest.json" />
Â  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
Â  <style>
Â  Â  :root{--accent:#1f6feb;--accent-2:#ff7b00;--bg:#f7fafc;--card:#ffffff;}
Â  Â  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--bg);color:#111;}
Â  Â  .container{display:flex;flex-direction:column;height:100vh;gap:12px;padding:12px;box-sizing:border-box;}
Â  Â  header{display:flex;align-items:center;justify-content:space-between;gap:12px;}
Â  Â  .brand{display:flex;align-items:center;gap:10px;}
Â  Â  .brand h1{margin:0;font-size:20px;letter-spacing:0.5px;}
Â  Â  .tablet-info{text-align:right;font-size:13px;color:#444;}
Â  Â  .main{display:flex;gap:12px;flex:1;min-height:0;}
Â  Â  #map{flex:1;border-radius:12px;box-shadow:0 6px 16px rgba(0,0,0,0.08);}
Â  Â  .panel{
Â  Â  Â  width:360px;
Â  Â  Â  min-width:260px;
Â  Â  Â  background:var(--card);
Â  Â  Â  border-radius:12px;
Â  Â  Â  box-shadow:0 6px 16px rgba(0,0,0,0.06);
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  overflow:hidden;
Â  Â  }
Â  Â  /* Static Booking Panel */
Â  Â  .booking-panel{
Â  Â  Â  padding:12px;
Â  Â  Â  border-bottom:1px solid #eee;
Â  Â  Â  background:#f9f9f9;
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  gap:8px;
Â  Â  }
Â  Â  .booking-row{
Â  Â  Â  display:flex;
Â  Â  Â  gap:8px;
Â  Â  }
Â  Â  .booking-row input{
Â  Â  Â  width:100%;
Â  Â  Â  padding:8px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  border:1px solid #ccc;
Â  Â  Â  font-size:15px;
Â  Â  }
Â  Â  .order-btn{
Â  Â  Â  background:var(--accent);
Â  Â  Â  color:white;
Â  Â  Â  border:none;
Â  Â  Â  padding:14px;
Â  Â  Â  font-size:17px;
Â  Â  Â  font-weight:600;
Â  Â  Â  border-radius:10px;
Â  Â  Â  cursor:pointer;
Â  Â  Â  width:100%;
Â  Â  Â  box-shadow:0 4px 8px rgba(31,111,235,0.2);
Â  Â  }
Â  Â  .order-btn:active{transform:translateY(1px);}
Â  Â  /* Scrollable Content */
Â  Â  .scroll-content{
Â  Â  Â  flex:1;
Â  Â  Â  overflow-y:auto;
Â  Â  Â  padding:20px;
Â  Â  }
Â  Â  .clear-btn{
Â  Â  Â  background:#dc3545;
Â  Â  Â  color:white;
Â  Â  Â  border:none;
Â  Â  Â  padding:8px 12px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  cursor:pointer;
Â  Â  Â  font-size:13px;
Â  Â  Â  margin-top:8px;
Â  Â  Â  width:100%;
Â  Â  }
Â  Â  .clear-btn:hover{background:#c82333;}
Â  Â  .small{font-size:13px;color:#666;}
Â  Â  .status{padding:10px;border-radius:8px;background:#f2f6ff;color:#08306b;font-weight:600;}
Â  Â  .driver-list{display:flex;flex-direction:column;gap:8px;max-height:140px;overflow:auto;}
Â  Â  .driver-item{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:8px;border-radius:8px;background:#fff;border:1px solid #f0f0f0;}
Â  Â  .small-btn{
Â  Â  Â  border:1px solid #ddd;
Â  Â  Â  background:#fff;
Â  Â  Â  padding:6px 10px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  cursor:pointer;
Â  Â  Â  font-size:13px;
Â  Â  }
Â  Â  table{width:100%;border-collapse:collapse;}
Â  Â  th,td{
Â  Â  Â  padding:8px 4px;
Â  Â  Â  text-align:left;
Â  Â  Â  border-bottom:1px solid #eee;
Â  Â  Â  font-size:14px;
Â  Â  }
Â  Â  th{background:#f0f0f0;font-size:13px;}
Â  Â  tbody td{font-weight:600;}
Â  Â  footer{display:flex;justify-content:space-between;gap:12px;font-size:12px;color:#666;}
Â  Â  .admin-panel{
Â  Â  Â  position:absolute;
Â  Â  Â  top:10px;
Â  Â  Â  left:50%;
Â  Â  Â  transform:translateX(-50%);
Â  Â  Â  background:#fff;
Â  Â  Â  padding:12px;
Â  Â  Â  border-radius:12px;
Â  Â  Â  box-shadow:0 6px 16px rgba(0,0,0,0.1);
Â  Â  Â  z-index:1000;
Â  Â  Â  display:none;
Â  Â  Â  width:300px;
Â  Â  }
Â  Â  .admin-panel h3{margin:0 0 10px 0;font-size:16px;}
Â  Â  .admin-panel .close-btn{float:right;cursor:pointer;color:#555;}
Â  Â  #logPanel{
Â  Â  Â  position:fixed;
Â  Â  Â  bottom:0;
Â  Â  Â  left:0;
Â  Â  Â  right:0;
Â  Â  Â  background:#fff;
Â  Â  Â  border-top:2px solid var(--accent);
Â  Â  Â  box-shadow:0 -4px 16px rgba(0,0,0,0.2);
Â  Â  Â  max-height:0;
Â  Â  Â  overflow:hidden;
Â  Â  Â  transition:max-height 0.4s ease;
Â  Â  Â  padding:0 12px;
Â  Â  Â  z-index: 2000;
Â  Â  }
Â  Â  #logPanel.open{max-height:40vh;padding:12px;}
Â  Â  #logOutput{
Â  Â  Â  font-family:monospace;
Â  Â  Â  font-size:12px;
Â  Â  Â  white-space:pre-wrap;
Â  Â  Â  background:#f9fafc;
Â  Â  Â  padding:8px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  height:100%;
Â  Â  Â  overflow:auto;
Â  Â  }
Â  Â  @media(max-width:900px){
Â  Â  Â  .main{flex-direction:column;}
Â  Â  Â  .panel{width:100%;}
Â  Â  Â  .booking-row input{font-size:14px;}
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="container">
Â  Â  <header>
Â  Â  Â  <div class="brand">
Â  Â  Â  Â  <div style="width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,#004400,#228B22);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;">ğŸ‰</div>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h1>Black Cab Unite â€” Coventry Rugby</h1>
Â  Â  Â  Â  Â  <div class="small">Butts Park Arena</div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div class="tablet-info">
Â  Â  Â  Â  <button class="small-btn" id="logBtn">View Log</button>
Â  Â  Â  Â  <button class="small-btn" id="adminBtn">Admin Panel</button>
Â  Â  Â  </div>
Â  Â  </header>

Â  Â  <div class="main">
Â  Â  Â  <div id="map"></div>
Â  Â  Â  <div class="panel">
Â  Â  Â  Â  <div class="booking-panel">
Â  Â  Â  Â  Â  <div class="booking-row">
Â  Â  Â  Â  Â  Â  <input type="text" id="customerName" placeholder="Customer name" />
Â  Â  Â  Â  Â  Â  <input type="tel" id="customerPhone" placeholder="+44 7123 456789" />
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <button class="order-btn" id="orderBtn">ORDER TAXI</button>
Â  Â  Â  Â  Â  <button class="clear-btn" id="clearStorageBtn">ğŸ—‘ï¸ Clear All Data</button>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="scroll-content">
Â  Â  Â  Â  Â  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
Â  Â  Â  Â  Â  Â  <div style="font-weight:700">Nearby Drivers</div>
Â  Â  Â  Â  Â  Â  <button class="small-btn" id="simulateBtn">Toggle Sim Drivers</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <div class="driver-list" id="driverList"></div>

Â  Â  Â  Â  Â  <div style="margin-top:16px;">
Â  Â  Â  Â  Â  Â  <div style="font-weight:700;margin-bottom:8px;">Current Jobs</div>
Â  Â  Â  Â  Â  Â  <table id="jobsTable">
Â  Â  Â  Â  Â  Â  Â  <thead><tr><th>ID</th><th>Name</th><th>Phone</th><th>Driver</th><th>Status</th></tr></thead>
Â  Â  Â  Â  Â  Â  Â  <tbody></tbody>
Â  Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <footer>
Â  Â  Â  <div>Black Cab Unite â€” Coventry Rugby Club</div>
Â  Â  Â  <div>Topics: pubs/requests/{pub_id} â€¢ drivers/tokens â€¢ jobs/+/status</div>
Â  Â  </footer>

Â  Â  <div class="admin-panel" id="adminPanel">
Â  Â  Â  <span class="close-btn" id="closeAdmin">&times;</span>
Â  Â  Â  <h3>Admin Panel</h3>
Â  Â  Â  <div>
Â  Â  Â  Â  <label>Driver ID:</label>
Â  Â  Â  Â  <input type="text" id="adminDriverId" placeholder="driver-01" />
Â  Â  Â  Â  <button class="small-btn" id="addDriverBtn">Add</button>
Â  Â  Â  Â  <button class="small-btn" id="removeDriverBtn">Remove</button>
Â  Â  Â  </div>
Â  Â  Â  <div style="margin-top:8px;"><button class="small-btn" id="allowAllBtn">Debug: Allow All</button></div>
Â  Â  Â  <div style="margin-top:12px;"><strong>Allowed:</strong><ul id="allowedDriversList"></ul></div>
Â  Â  </div>

Â  Â  <div id="logPanel">
Â  Â  Â  <h3 style="margin:0 0 8px 0;">ğŸ“‹ Activity Log</h3>
Â  Â  Â  <div id="logOutput"></div>
Â  Â  Â  <button class="small-btn" onclick="clearLog()">Clear Log</button>
Â  Â  </div>

Â  </div>

Â  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
Â  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
Â  <script>
Â  Â  // === CONFIG ===
Â  Â  const PUB_ID = 'coventry-rugby-butts-park';
Â  Â  const PUB_NAME = 'Coventry Rugby â€” Butts Park Arena';
Â  Â  const PUB_COORDS = { lat: 52.407234, lng: -1.525504 };
Â  Â  const BIDDING_WINDOW_MS = 60_000; // 60 seconds

Â  Â  // ===== FCM PUSH VIA CLOUD FUNCTION (HTTP) =====
Â  Â  const CLOUD_FUNCTION_URL = 'https://europe-west2-cabunite.cloudfunctions.net/sendJobAlertHttp';

Â  Â  async function sendPushToDriver(driverId, fcmToken, jobId, reason) {
Â  Â  Â  if (!driverId || typeof driverId !== 'string' || driverId.trim() === '') {
Â  Â  Â  Â  logMsg(`âš ï¸ Skip push: invalid driverId "${driverId}"`);
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  driverId = driverId.trim();

Â  Â  Â  if (!fcmToken) {
Â  Â  Â  Â  logMsg(`âŒ No FCM token for ${driverId}`);
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  try {
Â  Â  Â  Â  logMsg(`ğŸ“¤ Sending push to ${driverId}...`);
Â  Â  Â  Â  const response = await fetch(CLOUD_FUNCTION_URL, {
Â  Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  Â  Â  body: JSON.stringify({ driverId, fcmToken, jobId, reason })
Â  Â  Â  Â  });

Â  Â  Â  Â  const data = await response.json();

Â  Â  Â  Â  if (response.ok && data.messageId) {
Â  Â  Â  Â  Â  logMsg(`âœ… Push sent to ${driverId} (${data.messageId})`);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  logMsg(`âŒ Push failed for ${driverId}: ${data.error || JSON.stringify(data)}`);
Â  Â  Â  Â  }
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  logMsg(`âŒ Push error for ${driverId}: ${err.message}`);
Â  Â  Â  }
Â  Â  }

Â  Â  // === SAFE JSON PARSING ===
Â  Â  function safeParseJson(key, fallback) {
Â  Â  Â  const item = localStorage.getItem(key);
Â  Â  Â  if (item === null || item === '') return fallback;
Â  Â  Â  try {
Â  Â  Â  Â  return JSON.parse(item);
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  console.warn(`Invalid JSON in localStorage.${key}:`, item);
Â  Â  Â  Â  localStorage.removeItem(key);
Â  Â  Â  Â  return fallback;
Â  Â  Â  }
Â  Â  }

Â  Â  // === STATE ===
Â  Â  let drivers = {}; // Driver state { driverId: { lat, lng, data: { status }, fcmToken, activeJobId, marker } }
Â  Â  const pendingJobs = {}; // { jobId: { ...jobData, bidCount, bids: { driverId: {lat, lng, ts} }, timeoutId } }
Â  Â  let visibleJobs = safeParseJson('visibleJobs', {});
Â  Â  let allowedDrivers = safeParseJson('allowedDrivers', []);
Â  Â  let debugAllowAll = false;
Â  Â  let simActive = false;

Â  Â  // === DOM ELEMENTS ===
Â  Â  const el = {
Â  Â  Â  driverList: document.getElementById('driverList'),
Â  Â  Â  customerName: document.getElementById('customerName'),
Â  Â  Â  customerPhone: document.getElementById('customerPhone'),
Â  Â  Â  orderBtn: document.getElementById('orderBtn'),
Â  Â  Â  simulateBtn: document.getElementById('simulateBtn'),
Â  Â  Â  jobsTable: document.querySelector("#jobsTable tbody"),
Â  Â  Â  adminPanel: document.getElementById('adminPanel'),
Â  Â  Â  closeAdmin: document.getElementById('closeAdmin'),
Â  Â  Â  adminBtn: document.getElementById('adminBtn'),
Â  Â  Â  adminDriverId: document.getElementById('adminDriverId'),
Â  Â  Â  addDriverBtn: document.getElementById('addDriverBtn'),
Â  Â  Â  removeDriverBtn: document.getElementById('removeDriverBtn'),
Â  Â  Â  allowAllBtn: document.getElementById('allowAllBtn'),
Â  Â  Â  allowedDriversList: document.getElementById('allowedDriversList'),
Â  Â  Â  logBtn: document.getElementById('logBtn'),
Â  Â  Â  logPanel: document.getElementById('logPanel'),
Â  Â  Â  logOutput: document.getElementById('logOutput'),
Â  Â  Â  clearStorageBtn: document.getElementById('clearStorageBtn')
Â  Â  };

Â  Â  // === LOGGING ===
Â  Â  function logMsg(msg){
Â  Â  Â  const ts = new Date().toLocaleTimeString();
Â  Â  Â  const entry = `[${ts}] ${msg}\n`;
Â  Â  Â  // Append to logs and only keep the last ~100 lines for performance
Â  Â  Â  const logs = ((localStorage.getItem('activityLog') || '') + entry).split('\n');
Â  Â  Â  const truncatedLogs = logs.slice(-100).join('\n'); 
Â  Â  Â  localStorage.setItem('activityLog', truncatedLogs);
Â  Â  Â  el.logOutput.textContent = truncatedLogs;
Â  Â  Â  el.logOutput.scrollTop = el.logOutput.scrollHeight;
Â  Â  }

Â  Â  el.logBtn.onclick = () => el.logPanel.classList.toggle('open');
Â  Â  function clearLog(){ localStorage.removeItem('activityLog'); el.logOutput.textContent = ''; }

Â  Â  el.clearStorageBtn.onclick = () => {
Â  Â  Â  if (confirm("âš ï¸ Clear ALL data?")) {
Â  Â  Â  Â  localStorage.clear();
Â  Â  Â  Â  visibleJobs = {};
Â  Â  Â  Â  drivers = {};
Â  Â  Â  Â  Object.values(pendingJobs).forEach(job => clearTimeout(job.timeoutId));
Â  Â  Â  Â  for (const key in pendingJobs) { delete pendingJobs[key]; }
Â  Â  Â  Â  map.eachLayer(layer => {
Â  Â  Â  Â  Â  // Remove all markers/circles except the initial map layer and the pub marker (Crude but effective)
Â  Â  Â  Â  Â  if (layer instanceof L.CircleMarker || layer instanceof L.Marker && layer.getLatLng().lat !== PUB_COORDS.lat) {
Â  Â  Â  Â  Â  Â  map.removeLayer(layer);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  updateJobsTable();
Â  Â  Â  Â  el.driverList.innerHTML = '';
Â  Â  Â  Â  el.logOutput.textContent = '';
Â  Â  Â  Â  logMsg("ğŸ—‘ï¸ All local storage cleared");
Â  Â  Â  }
Â  Â  };

Â  Â  // === MAP SETUP ===
Â  Â  const map = L.map('map').setView([PUB_COORDS.lat, PUB_COORDS.lng], 15);
Â  Â  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
Â  Â  L.marker([PUB_COORDS.lat, PUB_COORDS.lng]).addTo(map).bindPopup(PUB_NAME);

Â  Â  // === HELPERS ===
Â  Â  function distanceMeters(a, b) {
Â  Â  Â  const R = 6371000;
Â  Â  Â  const toRad = x => x * Math.PI / 180;
Â  Â  Â  const Ï†1 = toRad(a.lat), Ï†2 = toRad(b.lat);
Â  Â  Â  const Î”Ï† = toRad(b.lat - a.lat), Î”Î» = toRad(b.lng - a.lng);
Â  Â  Â  const a_ = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î»/2)**2;
Â  Â  Â  return R * 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
Â  Â  }
Â  Â  function getColorForDriver(driverId) {
Â  Â  Â  let hash = 0;
Â  Â  Â  for (let i = 0; i < driverId.length; i++) {
Â  Â  Â  Â  hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
Â  Â  Â  }
Â  Â  Â  const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
Â  Â  Â  return "#" + "00000".substring(0, 6 - c.length) + c;
Â  Â  }

Â  Â  // === DRIVER MANAGEMENT (Ensure no optional chaining) ===
Â  Â  function updateDriver(id, lat, lng, meta = {}) {
Â  Â  Â  if (!id) return;
Â  Â  Â  
Â  Â  Â  // Initialize or update driver data first
Â  Â  Â  if (!drivers[id]) { 
Â  Â  Â  Â  drivers[id] = { 
Â  Â  Â  Â  Â  lat: lat, 
Â  Â  Â  Â  Â  lng: lng, 
Â  Â  Â  Â  Â  data: { status: 'unknown', ...meta }, 
Â  Â  Â  Â  Â  fcmToken: null, 
Â  Â  Â  Â  Â  lastActive: Date.now(), 
Â  Â  Â  Â  Â  activeJobId: null, 
Â  Â  Â  Â  Â  marker: null 
Â  Â  Â  Â  };
Â  Â  Â  } else {
Â  Â  Â  Â  drivers[id].lat = lat;
Â  Â  Â  Â  drivers[id].lng = lng;
Â  Â  Â  Â  drivers[id].data = { ...drivers[id].data, ...meta };
Â  Â  Â  }
Â  Â  Â  drivers[id].lastActive = Date.now();

Â  Â  Â  // Handle marker creation/movement
Â  Â  Â  if (!drivers[id].marker) {
Â  Â  Â  Â  const color = getColorForDriver(id);
Â  Â  Â  Â  drivers[id].marker = L.circleMarker([lat, lng], { color, radius: 8 }).addTo(map);
Â  Â  Â  Â  drivers[id].marker.bindPopup(id);
Â  Â  Â  } else {
Â  Â  Â  Â  drivers[id].marker.setLatLng([lat, lng]);
Â  Â  Â  }

Â  Â  Â  refreshDriverList();
Â  Â  }

Â  Â  function refreshDriverList() {
Â  Â  Â  el.driverList.innerHTML = '';
Â  Â  Â  Object.entries(drivers).forEach(([id, d]) => {
Â  Â  Â  Â  const dist = distanceMeters(d, PUB_COORDS);
Â  Â  Â  Â  // Check existence explicitly (no optional chaining)
Â  Â  Â  Â  const statusText = (d.data && d.data.status) || 'unknown'; 
Â  Â  Â  Â  const activeJobInfo = d.activeJobId ? ` (Job: ${d.activeJobId.substring(d.activeJobId.length - 4)})` : '';
Â  Â  Â  Â  const div = document.createElement('div');
Â  Â  Â  Â  div.className = 'driver-item';
Â  Â  Â  Â  div.innerHTML = `
Â  Â  Â  Â  Â  <div><b>${id}</b><div class="small">${statusText}${activeJobInfo}</div></div>
Â  Â  Â  Â  Â  <div>${dist < 1000 ? dist.toFixed(0) + 'm' : (dist / 1000).toFixed(1) + 'km'}</div>
Â  Â  Â  Â  `;
Â  Â  Â  Â  el.driverList.appendChild(div);
Â  Â  Â  });
Â  Â  }

Â  Â  // === JOBS TABLE MANAGEMENT ===
Â  Â  function updateJobsTable() {
Â  Â  Â  el.jobsTable.innerHTML = '';
Â  Â  Â  const jobs = Object.entries(visibleJobs).sort(([, a], [, b]) => b.ts - a.ts); // Sort by newest first
Â  Â  Â  jobs.forEach(([jobId, job]) => {
Â  Â  Â  Â  const row = el.jobsTable.insertRow();
Â  Â  Â  Â  // Safely access driver and status
Â  Â  Â  Â  const shortId = jobId.substring(jobId.length - 4);
Â  Â  Â  Â  const driver = job.driver || '-';
Â  Â  Â  Â  const status = job.status || 'unknown';

Â  Â  Â  Â  row.innerHTML = `
Â  Â  Â  Â  Â  <td>${shortId}</td>
Â  Â  Â  Â  Â  <td>${job.name}</td>
Â  Â  Â  Â  Â  <td>${job.phone}</td>
Â  Â  Â  Â  Â  <td>${driver}</td>
Â  Â  Â  Â  Â  <td>${status}</td>
Â  Â  Â  Â  `;
Â  Â  Â  });
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  }
Â  Â  function resendOfflineJobs() {
Â  Â  Â  Object.entries(visibleJobs).forEach(([jobId, job]) => {
Â  Â  Â  Â  // Resend only jobs that were queued or bidding
Â  Â  Â  Â  if (job.status === 'queued' || (job.status && job.status.startsWith('Bidding'))) {
Â  Â  Â  Â  Â  logMsg(`ğŸ’¡ Re-sending job ${jobId} (status: ${job.status}) after reconnect.`);
Â  Â  Â  Â  Â  // Clear any old timeouts if they somehow persisted
Â  Â  Â  Â  Â  if (pendingJobs[jobId] && pendingJobs[jobId].timeoutId) {
Â  Â  Â  Â  Â  Â  clearTimeout(pendingJobs[jobId].timeoutId);
Â  Â  Â  Â  Â  Â  delete pendingJobs[jobId];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  // Re-start the whole bidding process
Â  Â  Â  Â  Â  reAllocateJob(job);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }


Â  Â  // === MQTT ===
Â  Â  let client = null;
Â  Â  function connectMQTT(){
Â  Â  Â  client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt', { connectTimeout: 4000, reconnectPeriod: 1000 });

Â  Â  Â  client.on('connect', () => {
Â  Â  Â  Â  logMsg('âœ… Connected to MQTT');
Â  Â  Â  Â  client.subscribe(`drivers/+/location`);
Â  Â  Â  Â  client.subscribe(`drivers/+/status`);
Â  Â  Â  Â  client.subscribe(`jobs/+/status`);
Â  Â  Â  Â  client.subscribe('drivers/tokens');
Â  Â  Â  Â  client.subscribe(`pubs/requests/${PUB_ID}`);
Â  Â  Â  Â  resendOfflineJobs();
Â  Â  Â  });
Â  Â  Â  
Â  Â  Â  client.on('error', (err) => {
Â  Â  Â  Â  logMsg(`âŒ MQTT Error: ${err.message}`);
Â  Â  Â  });
Â  Â  Â  client.on('close', () => {
Â  Â  Â  Â  logMsg('ğŸ”´ MQTT Disconnected');
Â  Â  Â  });


Â  Â  Â  client.on('message', (topic, msg) => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  const data = JSON.parse(msg.toString());
Â  Â  Â  Â  Â  logMsg(`ğŸ“¡ ${topic} -> ${JSON.stringify(data)}`);

Â  Â  Â  Â  Â  if (topic.endsWith('/location')) {
Â  Â  Â  Â  Â  Â  const id = topic.split('/')[1];
Â  Â  Â  Â  Â  Â  updateDriver(id, data.lat, data.lng, data);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  if (topic === 'drivers/tokens') {
Â  Â  Â  Â  Â  Â  const { driverId, fcmToken } = data;
Â  Â  Â  Â  Â  Â  if (driverId && fcmToken) {
Â  Â  Â  Â  Â  Â  Â  if (!drivers[driverId]) {
Â  Â  Â  Â  Â  Â  Â  Â  // Initialize new driver with default location/status
Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId] = { lat: PUB_COORDS.lat, lng: PUB_COORDS.lng, data: { status: 'idle' }, fcmToken: fcmToken, lastActive: Date.now(), activeJobId: null, marker: null };
Â  Â  Â  Â  Â  Â  Â  Â  // Create marker only if location data is present/fresh, or update if it arrives later
Â  Â  Â  Â  Â  Â  Â  Â  if (!drivers[driverId].marker) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  const color = getColorForDriver(driverId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].marker = L.circleMarker([PUB_COORDS.lat, PUB_COORDS.lng], { color, radius: 8 }).addTo(map);
Â  Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].marker.bindPopup(driverId);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].fcmToken = fcmToken;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  drivers[driverId].lastActive = Date.now();
Â  Â  Â  Â  Â  Â  Â  logMsg(`âœ… FCM token received/updated for ${driverId}`);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // DRIVER STATUS CHANGES
Â  Â  Â  Â  Â  if (topic.startsWith("drivers/") && topic.endsWith("/status")) {
Â  Â  Â  Â  Â  Â  const driverId = topic.split('/')[1];
Â  Â  Â  Â  Â  Â  if (driverId === 'tokens') return;

Â  Â  Â  Â  Â  Â  // Initialize driver if status arrives before location/token
Â  Â  Â  Â  Â  Â  if (!drivers[driverId]) {
Â  Â  Â  Â  Â  Â  Â  drivers[driverId] = { lat: PUB_COORDS.lat, lng: PUB_COORDS.lng, data: { status: 'unknown' }, fcmToken: null, lastActive: Date.now(), activeJobId: null, marker: null };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  drivers[driverId].data.status = data.status;
Â  Â  Â  Â  Â  Â  drivers[driverId].lastActive = data.ts || Date.now();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Update active job status based on driver report
Â  Â  Â  Â  Â  Â  if (data.status === 'allocated' || data.status === 'on_route' || data.status === 'arrived') {
Â  Â  Â  Â  Â  Â  Â  drivers[driverId].activeJobId = data.jobId;
Â  Â  Â  Â  Â  Â  } else if (data.status === 'complete' || data.status === 'available' || data.status === 'idle' || data.status === 'offline') {
Â  Â  Â  Â  Â  Â  Â  drivers[driverId].activeJobId = null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  refreshDriverList();

Â  Â  Â  Â  Â  Â  // CRITICAL: RE-ALLOCATE JOB IF DRIVER WITH ALLOCATED JOB GOES OFFLINE/BUSY
Â  Â  Â  Â  Â  Â  const assignedJobId = Object.keys(visibleJobs).find(jobId => {
Â  Â  Â  Â  Â  Â  Â  const job = visibleJobs[jobId];
Â  Â  Â  Â  Â  Â  Â  return job.driver === driverId && (job.status === 'allocated' || job.status === 'on_route' || job.status === 'arrived');
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  if (assignedJobId) {
Â  Â  Â  Â  Â  Â  Â  const job = visibleJobs[assignedJobId];
Â  Â  Â  Â  Â  Â  Â  if (data.status === 'busy' || data.status === 'offline') {
Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`âš ï¸ Driver ${driverId} (allocated to job ${assignedJobId}) went ${data.status}. Re-allocating job.`);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Notify all previous bidders that the driver is unavailable
Â  Â  Â  Â  Â  Â  Â  Â  // Ensure bidderList exists before iterating (Safety check)
Â  Â  Â  Â  Â  Â  Â  Â  if (job.bidderList) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  job.bidderList.forEach(bidderId => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`jobs/${assignedJobId}/result/${bidderId}`, JSON.stringify({ result: "driver_unavailable" }));
Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].activeJobId = null; // Clear driver's active job
Â  Â  Â  Â  Â  Â  Â  Â  reAllocateJob(job);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // JOB STATUS UPDATES (BIDDING, COMPLETION, ETC.)
Â  Â  Â  Â  Â  if (topic.startsWith('jobs/') && topic.endsWith('/status')) {
Â  Â  Â  Â  Â  Â  const jobId = topic.split('/')[1];
Â  Â  Â  Â  Â  Â  if (visibleJobs[jobId]) {
Â  Â  Â  Â  Â  Â  Â  if (data.status === 'bidding' && data.driver) {
Â  Â  Â  Â  Â  Â  Â  Â  const driverId = data.driver;

Â  Â  Â  Â  Â  Â  Â  Â  // â­ CRITICAL FIX: Initialise driver state if it doesn't exist *before* checks
Â  Â  Â  Â  Â  Â  Â  Â  if (!drivers[driverId]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`ğŸ’¡ Initializing state for new bidding driver: ${driverId}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lat: data.lat || PUB_COORDS.lat,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lng: data.lng || PUB_COORDS.lng,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data: { status: 'idle' },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fcmToken: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastActive: Date.now(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  activeJobId: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  marker: null
Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  // Run updateDriver to initialize marker and location safely
Â  Â  Â  Â  Â  Â  Â  Â  Â  updateDriver(driverId, drivers[driverId].lat, drivers[driverId].lng, drivers[driverId].data);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // **SECURITY FIX 1: Reject bid if driver is already bidding/active on another job**
Â  Â  Â  Â  Â  Â  Â  Â  if (drivers[driverId].activeJobId && drivers[driverId].activeJobId !== jobId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`âŒ Driver ${driverId} rejected bid for ${jobId}: already active on ${drivers[driverId].activeJobId}`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "rejected_multi_bid" }));
Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (!pendingJobs[jobId]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  // If the job somehow wasn't in pendingJobs (edge case), initialize it and set the timer.
Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingJobs[jobId] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ...visibleJobs[jobId],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bidCount: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bids: {},
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timeoutId: setTimeout(() => finalizeBidding(jobId), BIDDING_WINDOW_MS)
Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (!pendingJobs[jobId].bids[driverId]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingJobs[jobId].bidCount += 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingJobs[jobId].bids[driverId] = { lat: data.lat, lng: data.lng, timestamp: data.ts };
Â  Â  Â  Â  Â  Â  Â  Â  Â  drivers[driverId].activeJobId = jobId; // **SECURITY FIX 2: Lock the driver to this job during bidding**
Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  // â­ CRITICAL FIX: Ensure map marker is updated with the latest bid location and driver list is refreshed
Â  Â  Â  Â  Â  Â  Â  Â  Â  updateDriver(driverId, data.lat, data.lng, { status: drivers[driverId].data.status });

Â  Â  Â  Â  Â  Â  Â  Â  Â  visibleJobs[jobId].status = `Bidding (${pendingJobs[jobId].bidCount})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  visibleJobs[jobId].driver = '-';
Â  Â  Â  Â  Â  Â  Â  Â  Â  updateJobsTable();
Â  Â  Â  Â  Â  Â  Â  Â  Â  logMsg(`ğŸ“¥ Bid #${pendingJobs[jobId].bidCount} for ${jobId} from ${driverId}`);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  if (data.status !== 'bidding') {
Â  Â  Â  Â  Â  Â  Â  Â  visibleJobs[jobId].status = data.status;
Â  Â  Â  Â  Â  Â  Â  Â  visibleJobs[jobId].driver = data.driver || '-';
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Clear active job status if job is complete/cancelled
Â  Â  Â  Â  Â  Â  Â  Â  // Using reliable existence check for data.driver and drivers[data.driver]
Â  Â  Â  Â  Â  Â  Â  Â  if (data.driver && drivers[data.driver] && (data.status === 'complete' || data.status === 'cancelled')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  drivers[data.driver].activeJobId = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  refreshDriverList(); // Refresh list to show driver is available
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  updateJobsTable();
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch(e) { console.warn("MQTT parse error:", e); }
Â  Â  Â  });
Â  Â  }

Â  Â  // === JOBS / RE-ALLOCATION ===
Â  Â  function reAllocateJob(job) {
Â  Â  Â  logMsg(`ğŸ”„ Re-allocating job ${job.job}...`);
Â  Â  Â  const jobId = job.job;

Â  Â  Â  if (job.driver && drivers[job.driver]) {
Â  Â  Â  Â  drivers[job.driver].activeJobId = null; // Clear active job from canceling driver
Â  Â  Â  }

Â  Â  Â  if (pendingJobs[jobId]) {
Â  Â  Â  Â  clearTimeout(pendingJobs[jobId].timeoutId);
Â  Â  Â  Â  delete pendingJobs[jobId];
Â  Â  Â  }

Â  Â  Â  job.status = 'queued';
Â  Â  Â  job.driver = '-';
Â  Â  Â  job.bidderList = []; // Reset bidder list for fresh bidding round
Â  Â  Â  visibleJobs[jobId] = job;
Â  Â  Â  updateJobsTable();
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));

Â  Â  Â  client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(job));
Â  Â  Â  logMsg(`ğŸ“¤ Re-sent job ${jobId} for bidding.`);

Â  Â  Â  // Trigger FCM pushes to eligible drivers
Â  Â  Â  Object.entries(drivers).forEach(([id, driver]) => {
Â  Â  Â  Â  if (!id || !driver.fcmToken) return;

Â  Â  Â  Â  // SECURITY CHECK: Don't notify driver who is currently bidding/allocated to another job
Â  Â  Â  Â  if (driver.activeJobId && driver.activeJobId !== jobId) {
Â  Â  Â  Â  Â  logMsg(`ğŸš« Skip push to ${id}: already active on ${driver.activeJobId}`);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const isAllowed = debugAllowAll || allowedDrivers.includes(id);
Â  Â  Â  Â  // Using reliable existence check instead of optional chaining
Â  Â  Â  Â  const status = (driver.data && driver.data.status) || 'unknown';
Â  Â  Â  Â  const isActive = status === 'available' || status === 'idle';
Â  Â  Â  Â  const inRange = distanceMeters(driver, PUB_COORDS) <= 10_000;
Â  Â  Â  Â 
Â  Â  Â  Â  let reason = 'eligible';
Â  Â  Â  Â  if (!isAllowed) reason = 'not_allowed';
Â  Â  Â  Â  else if (!isActive) reason = 'not_available';
Â  Â  Â  Â  else if (!inRange) reason = 'out_of_range';

Â  Â  Â  Â  if (reason === 'eligible') {
Â  Â  Â  Â  Â  Â  sendPushToDriver(id, driver.fcmToken, job.job, 'reallocated_job');
Â  Â  Â  Â  Â  Â  job.bidderList.push(id);
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  pendingJobs[jobId] = {
Â  Â  Â  Â  ...job,
Â  Â  Â  Â  bidCount: 0,
Â  Â  Â  Â  bids: {},
Â  Â  Â  Â  timeoutId: setTimeout(() => finalizeBidding(jobId), BIDDING_WINDOW_MS)
Â  Â  Â  };
Â  Â  Â  refreshDriverList();
Â  Â  }

Â  Â  function sendOrder() {
Â  Â  Â  const name = el.customerName.value.trim();
Â  Â  Â  const phone = el.customerPhone.value.trim();

Â  Â  Â  if (!name || !phone) {
Â  Â  Â  Â  alert("Please enter a customer name and phone number.");
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  const jobId = 'job-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 2);
Â  Â  Â  const job = { 
Â  Â  Â  Â  job: jobId, 
Â  Â  Â  Â  name: name,
Â  Â  Â  Â  phone: phone,
Â  Â  Â  Â  lat: PUB_COORDS.lat, // Assuming pick up is always the pub location
Â  Â  Â  Â  lng: PUB_COORDS.lng, 
Â  Â  Â  Â  ts: Date.now(),
Â  Â  Â  Â  status: 'queued', 
Â  Â  Â  Â  driver: '-', 
Â  Â  Â  Â  bidderList: [] 
Â  Â  Â  };
Â  Â  Â  visibleJobs = { [jobId]: job, ...visibleJobs };
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  Â  updateJobsTable();

Â  Â  Â  if (client && client.connected) {
Â  Â  Â  Â  client.publish(`pubs/requests/${PUB_ID}`, JSON.stringify(job));
Â  Â  Â  Â 
Â  Â  Â  Â  Object.entries(drivers).forEach(([id, driver]) => {
Â  Â  Â  Â  Â  if (!id || !driver.fcmToken) return;

Â  Â  Â  Â  Â  // SECURITY CHECK: Don't notify driver who is currently bidding/allocated to another job
Â  Â  Â  Â  Â  if (driver.activeJobId) {
Â  Â  Â  Â  Â  Â  logMsg(`ğŸš« Skip push to ${id}: already active on ${driver.activeJobId}`);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  // Eligibility checks
Â  Â  Â  Â  Â  const isAllowed = debugAllowAll || allowedDrivers.includes(id);
Â  Â  Â  Â  Â  // Use explicit existence check for data and status
Â  Â  Â  Â  Â  const status = (driver.data && driver.data.status) || 'unknown';
Â  Â  Â  Â  Â  const isActive = status === 'available' || status === 'idle';
Â  Â  Â  Â  Â  const inRange = distanceMeters(driver, PUB_COORDS) <= 10_000;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  let reason = 'eligible';
Â  Â  Â  Â  Â  if (!isAllowed) reason = 'not_allowed';
Â  Â  Â  Â  Â  else if (!isActive) reason = 'not_available';
Â  Â  Â  Â  Â  else if (!inRange) reason = 'out_of_range';

Â  Â  Â  Â  Â  if (reason === 'eligible') {
Â  Â  Â  Â  Â  Â  Â  sendPushToDriver(id, driver.fcmToken, jobId, reason);
Â  Â  Â  Â  Â  Â  Â  job.bidderList.push(id);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  pendingJobs[jobId] = {
Â  Â  Â  Â  Â  ...job, bidCount: 0, bids: {},
Â  Â  Â  Â  Â  timeoutId: setTimeout(() => finalizeBidding(jobId), BIDDING_WINDOW_MS)
Â  Â  Â  Â  };
Â  Â  Â  Â  logMsg('ğŸ“¤ Sent job ' + jobId);
Â  Â  Â  Â  refreshDriverList();

Â  Â  Â  Â  // Clear input fields on successful order
Â  Â  Â  Â  el.customerName.value = '';
Â  Â  Â  Â  el.customerPhone.value = '';

Â  Â  Â  } else {
Â  Â  Â  Â  logMsg('ğŸ”´ Cannot send order: MQTT not connected.');
Â  Â  Â  Â  alert("Cannot send order: Server connection (MQTT) is down.");
Â  Â  Â  }
Â  Â  }

Â  Â  // === FINALIZE BIDDING (60s) ===
Â  Â  function finalizeBidding(jobId) {
Â  Â  Â  const job = pendingJobs[jobId];
Â  Â  Â  if (!job) return;

Â  Â  Â  let winner = null;
Â  Â  Â  const bids = Object.entries(job.bids || {});

Â  Â  Â  if (bids.length > 0) {
Â  Â  Â  Â  // **SECURITY FIX 3: Final validation on driver state at the moment of allocation**
Â  Â  Â  Â  const valid = bids.filter(([id]) => {
Â  Â  Â  Â  Â  const d = drivers[id];
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // Check driver object existence and data existence explicitly
Â  Â  Â  Â  Â  const status = (d && d.data) ? d.data.status : null;
Â  Â  Â  Â  Â  const isAvailable = d && (status === 'idle' || status === 'available');
Â  Â  Â  Â  Â  const isLockedToThisJob = d && d.activeJobId === jobId;

Â  Â  Â  Â  Â  if (!isAvailable) {
Â  Â  Â  Â  Â  Â  logMsg(`ğŸš¨ Bid from ${id} ignored: status is ${status || 'unknown'}.`);
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (!isLockedToThisJob) {
Â  Â  Â  Â  Â  Â  logMsg(`ğŸš¨ Bid from ${id} ignored: driver lock broken, active job: ${d ? d.activeJobId : 'null'}`);
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  });

Â  Â  Â  Â  if (valid.length > 0) {
Â  Â  Â  Â  Â  // Sort by distance to the pickup location (closest wins)
Â  Â  Â  Â  Â  valid.sort(([aId, a], [bId, b]) => {
Â  Â  Â  Â  Â  Â  const distA = distanceMeters(a, {lat: job.lat, lng: job.lng});
Â  Â  Â  Â  Â  Â  const distB = distanceMeters(b, {lat: job.lat, lng: job.lng});
Â  Â  Â  Â  Â  Â  return distA - distB;
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  winner = valid[0][0];
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (winner) {
Â  Â  Â  Â  // 1. Set job status and winner
Â  Â  Â  Â  visibleJobs[jobId].status = 'allocated';
Â  Â  Â  Â  visibleJobs[jobId].driver = winner;

Â  Â  Â  Â  // 2. Finalize driver's active job (should already be jobId, but ensures consistency)
Â  Â  Â  Â  drivers[winner].activeJobId = jobId;
Â  Â  Â  Â  drivers[winner].data.status = 'allocated';

Â  Â  Â  Â  // 3. Notify drivers
Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${winner}`, JSON.stringify({ result: "won" }));
Â  Â  Â  Â  bids.forEach(([driverId]) => {
Â  Â  Â  Â  Â  if (driverId !== winner) {
Â  Â  Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "lost" }));
Â  Â  Â  Â  Â  Â  // Unlock losing drivers safely
Â  Â  Â  Â  Â  Â  if (drivers[driverId]) drivers[driverId].activeJobId = null; 
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  logMsg(`ğŸ† ${jobId} â†’ ${winner}`);
Â  Â  Â  } else {
Â  Â  Â  Â  visibleJobs[jobId].status = 'no_bids';
Â  Â  Â  Â  visibleJobs[jobId].driver = '-';

Â  Â  Â  Â  bids.forEach(([driverId]) => {
Â  Â  Â  Â  Â  client.publish(`jobs/${jobId}/result/${driverId}`, JSON.stringify({ result: "no_valid_acceptance" }));
Â  Â  Â  Â  Â  // Unlock drivers who bid but failed to win safely
Â  Â  Â  Â  Â  if(drivers[driverId]) drivers[driverId].activeJobId = null;
Â  Â  Â  Â  });
Â  Â  Â  Â  logMsg(`â° ${jobId}: no valid bids`);
Â  Â  Â  }

Â  Â  Â  delete pendingJobs[jobId];
Â  Â  Â  updateJobsTable();
Â  Â  Â  refreshDriverList();
Â  Â  Â  localStorage.setItem('visibleJobs', JSON.stringify(visibleJobs));
Â  Â  }

Â  Â  // === ADMIN PANEL LOGIC ===
Â  Â  function refreshAllowedDriversList() {
Â  Â  Â  el.allowedDriversList.innerHTML = '';
Â  Â  Â  if (debugAllowAll) {
Â  Â  Â  Â  el.allowedDriversList.innerHTML = '<li>**DEBUG: ALL DRIVERS ALLOWED**</li>';
Â  Â  Â  Â  el.allowAllBtn.textContent = 'Debug: Disable All';
Â  Â  Â  Â  el.allowAllBtn.style.backgroundColor = '#28a745'; // Green for active debug
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  el.allowAllBtn.textContent = 'Debug: Allow All';
Â  Â  Â  el.allowAllBtn.style.backgroundColor = ''; // Default style
Â  Â  Â  allowedDrivers.forEach(id => {
Â  Â  Â  Â  const li = document.createElement('li');
Â  Â  Â  Â  li.textContent = id;
Â  Â  Â  Â  el.allowedDriversList.appendChild(li);
Â  Â  Â  });
Â  Â  Â  localStorage.setItem('allowedDrivers', JSON.stringify(allowedDrivers));
Â  Â  }

Â  Â  el.adminBtn.onclick = () => {
Â  Â  Â  el.adminPanel.style.display = 'block';
Â  Â  };
Â  Â  el.closeAdmin.onclick = () => {
Â  Â  Â  el.adminPanel.style.display = 'none';
Â  Â  };

Â  Â  el.addDriverBtn.onclick = () => {
Â  Â  Â  const id = el.adminDriverId.value.trim();
Â  Â  Â  if (id && !allowedDrivers.includes(id)) {
Â  Â  Â  Â  allowedDrivers.push(id);
Â  Â  Â  Â  logMsg(`ğŸ› ï¸ Added ${id} to allowed list.`);
Â  Â  Â  Â  refreshAllowedDriversList();
Â  Â  Â  Â  el.adminDriverId.value = '';
Â  Â  Â  }
Â  Â  };

Â  Â  el.removeDriverBtn.onclick = () => {
Â  Â  Â  const id = el.adminDriverId.value.trim();
Â  Â  Â  const index = allowedDrivers.indexOf(id);
Â  Â  Â  if (index > -1) {
Â  Â  Â  Â  allowedDrivers.splice(index, 1);
Â  Â  Â  Â  logMsg(`ğŸ› ï¸ Removed ${id} from allowed list.`);
Â  Â  Â  Â  refreshAllowedDriversList();
Â  Â  Â  Â  el.adminDriverId.value = '';
Â  Â  Â  }
Â  Â  };

Â  Â  el.allowAllBtn.onclick = () => {
Â  Â  Â  debugAllowAll = !debugAllowAll;
Â  Â  Â  logMsg(`ğŸ› ï¸ Debug Allow All is now: ${debugAllowAll}`);
Â  Â  Â  refreshAllowedDriversList();
Â  Â  };

Â  Â  // === SIMULATION LOGIC (BASIC) ===
Â  Â  let simDrivers = {};
Â  Â  let simInterval = null;

Â  Â  function toggleSimDrivers() {
Â  Â  Â  simActive = !simActive;
Â  Â  Â  el.simulateBtn.textContent = simActive ? 'Disable Sim Drivers' : 'Toggle Sim Drivers';
Â  Â  Â  el.simulateBtn.style.backgroundColor = simActive ? '#007bff' : '';
Â  Â  Â  el.simulateBtn.style.color = simActive ? 'white' : '#111';

Â  Â  Â  if (simActive) {
Â  Â  Â  Â  logMsg('ğŸ› ï¸ Simulation started.');
Â  Â  Â  Â  // Create a few simulated drivers
Â  Â  Â  Â  ['sim-01', 'sim-02', 'sim-03', 'sim-04'].forEach((id) => {
Â  Â  Â  Â  Â  if (!drivers[id]) {
Â  Â  Â  Â  Â  Â  simDrivers[id] = {
Â  Â  Â  Â  Â  Â  Â  lat: PUB_COORDS.lat + (Math.random() - 0.5) * 0.005,
Â  Â  Â  Â  Â  Â  Â  lng: PUB_COORDS.lng + (Math.random() - 0.5) * 0.008,
Â  Â  Â  Â  Â  Â  Â  fcmToken: 'SIMULATED_TOKEN_' + id,
Â  Â  Â  Â  Â  Â  Â  status: 'idle',
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // If the real drivers object has this driver (from previous run), use its state
Â  Â  Â  Â  Â  Â  simDrivers[id] = drivers[id];
Â  Â  Â  Â  Â  Â  simDrivers[id].status = drivers[id].data.status;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  // Ensure status is initialized for the map marker
Â  Â  Â  Â  Â  updateDriver(id, simDrivers[id].lat, simDrivers[id].lng, { status: simDrivers[id].status });
Â  Â  Â  Â  });
Â  Â  Â  Â  simInterval = setInterval(simLoop, 5000); // Update every 5 seconds
Â  Â  Â  } else {
Â  Â  Â  Â  logMsg('ğŸ› ï¸ Simulation stopped. Removing simulated drivers.');
Â  Â  Â  Â  clearInterval(simInterval);
Â  Â  Â  Â  Object.keys(simDrivers).forEach(id => {
Â  Â  Â  Â  Â  if (drivers[id] && drivers[id].marker) {
Â  Â  Â  Â  Â  Â  map.removeLayer(drivers[id].marker);
Â  Â  Â  Â  Â  Â  delete drivers[id];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  simDrivers = {};
Â  Â  Â  Â  refreshDriverList();
Â  Â  Â  }
Â  Â  }

Â  Â  function simLoop() {
Â  Â  Â  Object.entries(simDrivers).forEach(([id, d]) => {
Â  Â  Â  Â  // Simple random drift
Â  Â  Â  Â  const newLat = d.lat + (Math.random() - 0.5) * 0.0001;
Â  Â  Â  Â  const newLng = d.lng + (Math.random() - 0.5) * 0.0001;
Â  Â  Â  Â  d.lat = newLat;
Â  Â  Â  Â  d.lng = newLng;

Â  Â  Â  Â  // Get the live driver state from the main drivers object
Â  Â  Â  Â  const driverState = drivers[id];
Â  Â  Â  Â  const activeJob = driverState ? driverState.activeJobId : null;

Â  Â  Â  Â  if (activeJob) {
Â  Â  Â  Â  Â  // If driver is allocated to a job, simulate status updates
Â  Â  Â  Â  Â  const job = visibleJobs[activeJob];
Â  Â  Â  Â  Â  if (job) {
Â  Â  Â  Â  Â  Â  if (job.status === 'allocated') {
Â  Â  Â  Â  Â  Â  Â  // After a delay, move to 'on_route'
Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.3) {
Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`drivers/${id}/status`, JSON.stringify({ status: 'on_route', jobId: activeJob, ts: Date.now() }));
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (job.status === 'on_route') {
Â  Â  Â  Â  Â  Â  Â  // After a delay, move to 'arrived' (near the pub)
Â  Â  Â  Â  Â  Â  Â  if (distanceMeters(d, PUB_COORDS) < 200 && Math.random() < 0.3) {
Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`drivers/${id}/status`, JSON.stringify({ status: 'arrived', jobId: activeJob, ts: Date.now() }));
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else if (job.status === 'arrived') {
Â  Â  Â  Â  Â  Â  Â  // After a delay, move to 'complete'
Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  client.publish(`drivers/${id}/status`, JSON.stringify({ status: 'complete', jobId: activeJob, ts: Date.now() }));
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // If idle, simulate bidding on any pending job
Â  Â  Â  Â  Â  const pendingJobId = Object.keys(pendingJobs).find(pid => !pendingJobs[pid].bids[id]);
Â  Â  Â  Â  Â  if (pendingJobId && distanceMeters(d, PUB_COORDS) < 5000 && Math.random() < 0.5) {
Â  Â  Â  Â  Â  Â  client.publish(`jobs/${pendingJobId}/status`, JSON.stringify({ status: 'bidding', driver: id, lat: newLat, lng: newLng, ts: Date.now() }));
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Update location, ensuring status is safely read from driverState
Â  Â  Â  Â  updateDriver(id, newLat, newLng, { 
Â  Â  Â  Â  Â  status: (driverState && driverState.data) ? driverState.data.status : 'idle' 
Â  Â  Â  Â  });
Â  Â  Â  });
Â  Â  }

Â  Â  // === INITIALIZATION ===
Â  Â  el.orderBtn.onclick = sendOrder;
Â  Â  el.simulateBtn.onclick = toggleSimDrivers;
Â  Â  
Â  Â  // Re-fetch log and run initial updates
Â  Â  el.logOutput.textContent = localStorage.getItem('activityLog') || '';
Â  Â  updateJobsTable();
Â  Â  refreshAllowedDriversList();
Â  Â  
Â  Â  connectMQTT();
Â  Â  
Â  Â  // Service Worker registration (if file exists)
Â  Â  if ('serviceWorker' in navigator) {
Â  Â  Â  navigator.serviceWorker.register('service-worker.js').catch(err => {
Â  Â  Â  Â  logMsg(`âŒ Service Worker registration failed: ${err.message}`);
Â  Â  Â  });
Â  Â  }
Â  </script>
</body>
</html>
